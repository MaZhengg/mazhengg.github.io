<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[卡尔曼滤波推导]]></title>
    <url>%2F2019%2F01%2F04%2FKalman%20filter%2F</url>
    <content type="text"><![CDATA[本文主要记录卡尔曼滤波的推导过程，此记。 概念卡尔曼滤波，首先说一下，为什么要用“滤波”这个词？ 从带有噪声的数据中找到“最优估计”的过程就是“过滤”掉噪声的过程。卡尔曼滤波是最好的线性估计方法。 建立系统数学模型在实际应用中，我们可以将物理系统的运行过程看作是一个状态转换过程，卡尔曼滤波将状态空间理论引入到对物理系统的数学建模过程中来，其假设系统状态可以用$n$维空间的一个向量$X\in R^n$来表示。为了描述方便，我们作以下假设：1物理系统的状态转换过程可以描述为一个离散时间的随机过程;2系统状态受控制输入的影响；3系统状态及观测过程都不可避免受噪声影响;4对系统状态是非直接可观测的。 在以上假设前提下，定义系统状态变量为$x_k\in R^n$，系统控制输入为$u_k$，系统过程激励噪声为$w_k$,可得出系统的状态随机差分方程为： $$x_k=Ax_{k-1}+Bu_{k-1}+w_{k-1}\tag{1}$$ 定义观测变量$z_k\in R^m$，观测噪声为$v_k$，得到量测方程： $$z_k=Hx_k+v_k\tag{2}$$ 假设$w_k,v_k$为相互独立，正态分布的白色噪声，过程激励噪声协方差矩阵为$Q$，观测噪声协方差矩阵为$R$，即： $$p(w)\sim N(0,Q)\tag{3}$$ $$p(v)\sim N(0,R)\tag{4}$$ $A,B,H$我们统称为状态变换矩阵，是状态变换过程中的调整系数，是从建立的系统数学模型中导出来的，这儿我们假设它们是常数。 滤波器计算原型 从建立的系统数学模型出发，可以导出卡尔曼滤波的计算原型，包括：时间更新方程和测量更新方程。 为了便于描述，做以下说明：(1)$\hat{x}_k\in R^n$，第$k$步之前的状态已知的情况下第$k$步的先验状态估计值（$\bar{}$代表先验,$\hat{}$代表估计）；(2)$\hat{x}_k\in R^n$ ，测量变量$z_k$已知情况下第$k$步的后验状态估计值。由此定义先验估计误差和后验估计误差： $$e_k^{-}\equiv x_k-\hat{x}_k^{-}\tag{5}$$ $$e_k\equiv x_k-\hat{x}_k\tag{6}\label{pos_estim_error}$$ 先验估计误差的协方差矩阵为： $$P_k^{-}=E(e_k^{-}e_k^{-T})\tag{7}$$ 后验估计误差的协方差矩阵为： $$P_k=E(e_ke_k^{T})\tag{8}\label{pos_estim_error_conv}$$ 先验估计$\hat{X}_k^{-}$和加权的测量变量$Z_k$及其预测$H\hat{X}_k^{-}$之差的线性组合构成了后验状态估计$\hat{X}_k$： $$\hat{x}_k=\hat{x}_k^{-}+K(z_k-\hat{x}_k^{-})\tag{9}\label{pos_estim}$$ 式中测量变量及其预测值之差$(z_k-\hat{X}_k^{-})$ 反映了预测值和实际值之间的不一致程度，称为测量过程的残余。残余为零表明二者完全吻合。$n\times m$阶矩阵$K$叫做残余的增益 ，作用是使\eqref{pos_estim_error_conv}式中的后验估计误差协方差最小。 可以通过以下步骤求出 K：将\eqref{pos_estim}式代入\eqref{pos_estim_error}式代入\eqref{pos_estim_error_conv}式，将$P_k$对$K$求导，使一阶导数为零，可以求出 $K$，$K$的一种形式为： $$K_k = P_k^{-}H^T(HP_k^{-}H^T+R)^{-1}\tag{10}\label{kalman_k}$$ 卡尔曼滤波器用反馈控制的方法估计过程状态： 滤波器估计过程某一时刻的状态， 然后以（含噪声的） 测量变量的方式获得反馈。 因此卡尔曼滤波器可分为两个部分： 时间更新方程和测量更新方程。 时间更新方程负责及时向前推算当前状态变量和误差协方差估计的值， 以便为下一个时间状态构造先验估计。 测量更新方程负责反馈――也就是说， 它将先验估计和新的测量变量结合以构造改进的后验估计。时间更新方程也可视为预估方程， 测量更新方程可视为校正方程。 最后的估计算法成为一种具有数值解的预估－校正算法， 如下图所示。 离散卡尔曼滤波器时间更新方程： $$\bar{x}k^{-}=A\bar{x}{k-1}+Bu_{k-1}\tag{11}$$ $$P_k^{-}=AP_{k-1}A^T + Q\tag{12}$$ 离散卡尔曼滤波器状态更新方程： $$K_k = P_k^{-}H^T(HP_k^{-}H^T+R)^{-1}\tag{13}\label{kalman_gain}$$ $$\bar{x}_k=\bar{x}_k^{-}K_k(z_k - H\hat{x}_k^{-})\tag{14}\label{pos_estim2}$$ $$P_k = (I-K_kH)P_k^{-}\tag{15}\label{pos_cov}$$ 测量更新方程首先做的是计算卡尔曼增益 $K_k$ 。 注意\eqref{kalman_gain}式和\eqref{kalman_k}式是相同的。 其次便测量输出以获得$z_k$， 然后按\eqref{pos_estim2}式（与\eqref{pos_estim}式相同） 产生状态的后验估计。 最后按\eqref{pos_cov}式估计状态的后验协方差。 最后，滤波器的整个操作流程如下图所示：]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>Kalman Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视觉SLAM十四讲中的知识]]></title>
    <url>%2F2018%2F12%2F21%2FSLAM%20BOOK%2F</url>
    <content type="text"><![CDATA[本文主要记录视觉SLAM十四讲中的相关知识点，此记。 C++知识点智能指针 几乎每一个有分量的程序都需要“在相同时间的多处地点处理或使用对象”的能力。为此，我们必须在程序的多个地点指向（refer to）同一对象。虽然C++语言提供引用（reference）和指针（pointer），还是不够，因为我们往往必须确保当“指向对象”的最末一个引用被删除时该对象本身也被删除，毕竟对象被删除时析构函数可以要求某些操作，例如释放内存或归还资源等等。 所以我们需要“当对象再也不被使用时就被清理”的语义。Class shared_ptr提供了这样的共享式拥有语义。也就是说，多个shared_ptr可以共享（或说拥有）同一对象。对象的最末一个拥有者有责任销毁对象，并清理与该对象相关的所有资源。 shared_ptr的目标就是，在其所指向的对象不再被使用之后（而非之前），自动释放与对象相关的资源。 使用Mat::ptr模板函数123ushort d = depth_.ptr&lt;ushort&gt;(y)[x];//这个还是.ptr模板函数定位像素值的方法，记住用法//返回的是depth_的第y行数据的第x个的深度值 12345678910111213141516171819202122232425262728293031int main()&#123; Mat m(400, 400, CV_8UC3, Scalar(226, 46, 166)); imshow("Before", m); for (int row = 0; row &lt; m.rows; row++) &#123; if (row % 5 == 0) &#123; // data 是 uchar* 类型的, m.ptr&lt;uchar&gt;(row) 返回第 row 行数据的首地址 // 需要注意的是该行数据是按顺序存放的,也就是对于一个 3 通道的 Mat, 一个像素有 // 有 3 个通道值, [B,G,R][B,G,R][B,G,R]... 所以一行长度为: // sizeof(uchar) * m.cols * m.channels() 个字节 uchar* data = m.ptr&lt;uchar&gt;(row); for (int col = 0; col &lt; m.cols; col++) &#123; data[col * 3] = 102; //第row行的第col个像素点的第一个通道值 Blue data[col * 3 + 1] = 217; // Green data[col * 3 + 2] = 239; // Red &#125; &#125; &#125; imshow("After", m); cout &lt;&lt; (int)m.at&lt;Vec3b&gt;(0, 0)[0] &lt;&lt; ','; //利用 Fn 1 介绍的方法输出一下像素值到控制台 cout &lt;&lt; (int)m.at&lt;Vec3b&gt;(0, 0)[1] &lt;&lt; ','; cout &lt;&lt; (int)m.at&lt;Vec3b&gt;(0, 0)[2] &lt;&lt; endl; cvWaitKey(); return 0;&#125; 单件模式（Singleton）定义：单件模式确保一个类只有一个实例，并提供一个全局访问点。把Config写成单件模式（Singleton），它只有一个全局对象，当我们设置参数文件时，创建该对象并读取参数，随后就可以在任意地方访问参数值，最后在程序结束时自动销毁。 std::min_element和std::max_elementReturns an iterator pointing to the element with the smallest（largest） value in the range [first,last).这就是书中使用了std::min_element和lambda表达式的程序，这段程序具体实现的功能是找到matches这个用来存放匹配的关键点的描述子中描述子的最小的距离，然后赋值给min_dis，matches是存放Dmatch这个描述子类的容器，所有最后会有-&gt;distance表示赋给min_dis的是距离。 返回容器或者数组中最大值和最小值。max/min_element(first,end,cmp);其中cmp为可选择参数 1234[] ( const cv::DMatch&amp; m1, const cv::DMatch&amp; m2 ) &#123; return m1.distance &lt; m2.distance; &#125; 这里的lamda函数相当于:1234bool cmp(const cv::DMatch&amp; m1, const cv::DMatch&amp; m2)&#123; return m1.distance &lt; m2.distance; &#125; 实际的功能就是将matches中的所有描述子进行了个排序，然后min_element取了第一个及最小的那个的distance赋给了min_dis c++ 11特性：auto关键字auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型，类似的关键字还有decltype。举个例子：用于代替冗长复杂、变量使用范围专一的变量声明。 想象一下在没有auto的时候，我们操作标准库时经常需要这样：12345678910#include&lt;string&gt;#include&lt;vector&gt;int main()&#123; std::vector&lt;std::string&gt; vs; for (std::vector&lt;std::string&gt;::iterator i = vs.begin(); i != vs.end(); i++) &#123; //... &#125;&#125; 这样看代码写代码实在烦得很。有人可能会说为何不直接使用using namespace std，这样代码可以短一点。实际上这不是该建议的方法（C++Primer对此有相关叙述）。使用auto能简化代码：12345678910#include&lt;string&gt;#include&lt;vector&gt;int main()&#123; std::vector&lt;std::string&gt; vs; for (auto i = vs.begin(); i != vs.end(); i++) &#123; //.. &#125;&#125; for循环中的i将在编译时自动推导其类型，而不用我们显式去定义那长长的一串。在定义模板函数时，用于声明依赖模板参数的变量类型。123456template &lt;typename _Tx,typename _Ty&gt;void Multiply(_Tx x, _Ty y)&#123; auto v = x*y; std::cout &lt;&lt; v;&#125; 若不使用auto变量来声明v，那这个函数就难定义啦，不到编译的时候，谁知道x*y的真正类型是什么呢？模板函数依赖于模板参数的返回值12345template &lt;typename _Tx, typename _Ty&gt;auto multiply(_Tx x, _Ty y)-&gt;decltype(_Tx*_Ty)&#123; return x*y;&#125; 当模板函数的返回值依赖于模板的参数时，我们依旧无法在编译代码前确定模板参数的类型，故也无从知道返回值的类型，这时我们可以使用auto。格式如上所示。 图像知识OpenCV函数函数cvRound，cvFloor，cvCeil 都是用一种舍入的方法将输入浮点数转换成整数： cvRound:返回跟参数最接近的整数值； cvFloor:返回不大于参数的最大整数值；*cvCeil:返回不小于参数的最小整数值。 opencv软件opencv2和opencv3共存opencv2默认安装，安装路径一般是“usr/local”，在安装opencv3时，先下载3的源码，解压后12mkdir buildcd build 更改安装目录（先在/usr/local下新建文件夹opencv3）， bashcmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local/opencv3 ..1234然后编译opencv3即可，``` bashmakesudo make install 这样就把3安装在opencv3文件夹了(bin lib share include) build过程中可能报错， ICV: Failed to download ICV package: ippicv_linux_20151201.tgz. Status=7;”Couldn’t connect to server”，解决方法是手动下载ippicv_linux_20151201.tgz，并替换掉opencv-3.1.0/3rdparty/ippicv/downloads/linux-*下的相应文件即可，可以直接从该地址下载：ippicv_linux_20151201.tgz 在使用的时候，在CMakelists.txt中，如要用3，在find_package前指明路径：12set(OpenCV_DIR /usr/local/opencv3/share/OpenCV)find_package(OpenCV 3 REQUIRED) ORB特征构造函数1234567891011121314151617static Ptr&lt;ORB&gt; cv::ORB::create ( int nfeatures = 500, float scaleFactor = 1.2f, int nlevels = 8, int edgeThreshold = 31, int firstLevel = 0, int WTA_K = 2, int scoreType = ORB::HARRIS_SCORE, int patchSize = 31, int fastThreshold = 20 )nfeatures:需要的特征点总数；scaleFactor:尺度因子；nlevels:金字塔层数；edgeThreshold:边界阈值；firstLevel:起始层；WTA_K：描述子形成方法,WTA_K=2表示，采用两两比较；scoreType:角点响应函数，可以选择Harris或者Fast的方法；patchSize:特征点邻域大小；]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++谷歌命名法]]></title>
    <url>%2F2018%2F12%2F21%2FC%2B%2B%E8%B0%B7%E6%AD%8C%E5%91%BD%E5%90%8D%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文主要记录易于理解，通用的C++命名规则，此记。 一般命名规则命名需要尽量是描述性的，避免缩写（特殊情况除外，比如特别常见的缩写num）。 1234int price_count_reader; // 没有缩写int num_errors; // "num" 是常用的惯例int num_dns_connections; // 大多数人都知道“DNS”代表什么int lstm_size; // "LSTM" 在机器学习中是常用的缩写 ！！！！！下面是不推荐的命名方法！！！！！！！！！1234567int n; // 毫无意义的名字.int nerr; // 模糊的缩写.int n_comp_conns; // 模糊的缩写.int wgc_connections; // 估计只有你们自己人知道这是代表什么.int pc_reader; // 很多东西可以简写为"pc".int cstmr_id; // 删除了一些中间的字母.FooBarRequestInfo fbri; // 这甚至都不是一个单词. 一些众所周知，比较常用的缩写是可以的，比如i表示迭代变量，T表示模板参数。 命名规则 类型 命名规则 可用特殊符号 举例 文件名 都是小写字母，可以用下划线“”和破折号“-”，如果没有习惯写法，一般用下划线“” “_”和“-” my_useful_class.cc， my_useful_class.h 类型名 类型名以大写字母开头，以下划线开始 无 类型名包括：classes, structs, type aliases, enums, and type template parameters ，MyExcitingClass, MyExcitingEnum. 变量名（一般变量名） 小写字母，单词之间加下划线 “_” a_local_variable 变量名（类成员变量名） 小写字母，单词之间加下划线，词尾加下划线 “_” a_class_data_member_ 变量名（结构体数据成员名） 小写字母，单词之间加下划线（或单个单词） “_” a_struct_data_member, name,pool 常数命名 常数或常量表达式，需要以小写字母“k”开头，后加大写字母开头的单词，在大写字母无法区分的时候可以添加下划线 “k”,“_” kAndroid8_0_0, kDaysInAWeek 函数名 常规函数名以大写字母开头，访问函数和赋值函数可以像一般变量命名规则一样 访问函数和赋值函数“_” AddTableEntry()，访问函数和赋值函数：int count() ， void set_count(int count) 命名空间 都是小写字母，最上层的命名空间是基于项目名称的，需要避免和常用的命名空间产生歧义 无 websearch 枚举类型名 枚举类型(for both scoped and unscoped enums)参考常数或者宏定义命名规则 “_” kEnumName 或者 ENUM_NAME 宏定义名 宏定义一般不要用，如果必须要用那么应该用全全大写字母，以破折号“_”间隔 “_” MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE 文件名 my_useful_class.cc my-useful-class.cc myusefulclass.cc myusefulclass_test.cc // _unittest and _regtest are deprecated. 类型名12345678910111213 // classes and structsclass UrlTable &#123; ...class UrlTableTester &#123; ...struct UrlTableProperties &#123; ...// typedefstypedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;// using aliasesusing PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;// enumsenum UrlTableErrors &#123; ... 变量名一般变量名1234string table_name; // OK - uses underscore.string tablename; // OK - all lowercase.string tableName; // Bad - mixed case. 类成员变量名1234567class TableInfo &#123; ... private: string table_name_; // OK - underscore at end. string tablename_; // OK. static Pool&lt;TableInfo&gt;* pool_; // OK.&#125;; 结构体数据成员名12345struct UrlTableProperties &#123; string name; int num_entries; static Pool&lt;UrlTableProperties&gt;* pool;&#125;; 常数命名12const int kDaysInAWeek = 7;const int kAndroid8_0_0 = 24; // Android 8.0.0 函数名123AddTableEntry()DeleteUrl()OpenFileOrDie() 特殊的访问函数或赋值函数12int count()void set_count(int count) 命名空间123websearch::indexwebsearch::index_utilwebsearch::index::frobber_internal for use in frobber.h 枚举类型名12345678910enum UrlTableErrors &#123; kOK = 0, kErrorOutOfMemory, kErrorMalformedInput,&#125;;enum AlternateUrlTableErrors &#123; OK = 0, OUT_OF_MEMORY = 1, MALFORMED_INPUT = 2,&#125;; 宏定义名宏定义一般不要用，如果必须要用那么应该用全大写和下划线间隔 12#define ROUND(x) ...#define PI_ROUNDED 3.0 命名规则之外如果你需要对一些C++已有命名规则之外的对象命名，可以参考现有的命名规则。 12345678910bigopen() function name, follows form of open()uint typedefbigpos struct or class, follows form of possparse_hash_map STL-like entity; follows STL naming conventionsLONGLONG_MAX a constant, as in INT_MAX]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS下IMU数据解析并发布-JY901（MPU9250）]]></title>
    <url>%2F2018%2F05%2F24%2FROS%E4%B8%8BIMU%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[进行ROS下机器人系统开发，需要用到IMU数据，所以需要做IMU数据解析，IMU设备是JY901（内置MPU9250）芯片，设备利用USB转TTL转换，采用了MZ-RS24T转换器，转换芯片为FT232RL，本文想要系统记录从IMU传出数据到数据转换，再到ROS下数据解析并发布IMU话题的过程及（部分）实现方法，此记。 设备连接及通信接口测试设备连接设备连接就是通过MZ-RS24T六合一转换器将TTL电平转换为USB，其中需要注意的就是将发送和接收线交叉连接，如图1所示。 windows下测试设备刚拿到设备需要确认设备是否可用，所以考虑在windows系统下测试，设备应该附带在windows的测试软件（miniIMUV4.3.11）和串口调试软件（SSCOM32），这些可以在他们的官方论坛维特智能上下载到，也可以直接到百度网盘下载，下载链接。windows下的驱动程序可以自动搜索安装就不多说了。 一些具体的测试方法在下载资料的使用说明中有具体的介绍，安装完驱动，确定能识别硬件，验证方法到我的电脑–管理–设备管理器–端口，一般显示为USB Serial Port(COM#)，然后打开miniIMUV4.3.11，可以正常显示在配置中选定的数据，说明硬件正常。 Linux下通信测试插入设备后，通过查看电脑的输入端口确定usb串口号，1ls /dev/tty* 查询到串口名为”/dev/ttyUSB0”，这样说明通信接口正常识别，后边会用的到。如果在后边中通信有问题可能是串口读取权限的问题，可以采用以下方式修改权限。1sudo chmod 666 /dev/ttyUSB0 IMU数据解析JY901模块是一款高精度的姿态测量模块，能够测量被测物体的姿态角度，以欧拉角或者四元素的方式输出。 模块的数据采用16进制的方式进行传输（在使用说明书中也有说明），这种方式的优点是效率高，可以用很少的字节传输需要的数据，比如一个数据1.523，如果用16进制方式传送的话，2个字节就够了，而用ascii码的话，需要5个字节，在需要大量数据传输的时候就比较浪费有限的带宽了。而16进制数据的缺点呢，就是可读性不强，不像Ascii码那样，直接就能读出数据了。 16进制数据传输的原理是这样的，先要确定数据的表示范围，然后是每个数据可用的字节数。比如角度的数据，每个角度的数据范围是±180度，而2个字节16进制数的表示范围是-32767-32768之间，那么我们就把±180的数据映射到±32768之间。假设原理的数据是x，变换以后的数据是y，那么y=x/180*32768。2个字节能表示的最小精度是1/32768*180=0.0055°，这对于角度的精度来说也够用了。下面具体讲解析的方法。在windows下先通过串口调试助手SSCOM3.2看模块的原始数据，打开相应的串口，注意要选择好正确的波特率，并且将模块的显示模式勾选为HEX显示。如图3 所示。 这里我们以只输出四元数数据为例来说明解析方法，由于这里我设置为只输出四元数数据，所以只有55 59开头的数据，例如55 59 F6 7A 94 00 9F 00 8B 23 FF。如果能看到这种以55 51, 55 52 或者55 53一直到55 59， 55 5A开头的数据，说明串口能够正常接收到数据了。根据使用说明书中的介绍，四元数的数据形式为 那么上述数据中F6 7A就是Q0的数据， 94 00就是Q1的数据，9F 00就是Q2的数据，8B 23就是Q3的数据，FF就是校验和。在Q0的数据中，F6是Q0L,7A是Q0H，那么完整的16进制数据应该是7AF6，这个16进制的数据应该如何表示为十进制的Q0数据就需要我们按照图5中的方法进行解析。 以上是在window中的串口工具读取到的数据，在Linux下我们通过serial功能包读取串口数据，下载地址Github。我们读取到的数据一般保存在一个std::string类型的变量中，比如strRead,这里我们首先将读取到的string数据转换为十六进制的字符串， 1234567891011121314std::string string_to_hex(const std::string&amp; input)&#123; static const char* const lut = "0123456789ABCDEF"; size_t len = input.length(); std::string output; output.reserve(2 * len); for (size_t i = 1; i &lt; len; ++i) &#123; const unsigned char c = input[i]; output.push_back(lut[c &gt;&gt; 4]); output.push_back(lut[c &amp; 15]); &#125; return output;&#125; 123string read;string strResult;strResult = string_to_hex(strRead); 然后我们需要根据一个数据包的报头来判断数据的开始，也就是找到55所在的位置，1data_package_start = strResult.find("55"); 然后我们将这样一组数据读取并保存到一个vector容器中，比如oValueList中123456//将string类型的十六进制数据转换为int类型,然后强制转换为unsigned short类型unsigned short hex2int(const string&amp; hexStr)&#123;char *offset;return strtol(hexStr.c_str(), &amp;offset, 16);&#125; 123456789101112type define unsigned short WORD;vector&lt;WORD&gt; oValueList;string strResultTemp;WORD wordValue;for (int k = 0; k &lt; 8; k++)&#123; strResultTemp = strResult.substr(data_package_start + 4 +2*k, 2); wordValue = hex2int(strResultTemp); oValueList.push_back(wordValue);&#125; 利用string类的函数stbstr()，提取从55 59之后（data_package_start+4）开始的2个字符，直到校验和之前。这样我们就将原来在string类型中以十六进制形式存储的两个字符（比如F6）转存为unsigned short类型（占两个字节），并且push进vector容器中（oValueList[0]）。这样就可以通过vector容器的索引号得到四元数中各个量(Q0,Q1,Q2,Q3)的高低字节（Q0L,Q0H,Q1L,Q1H……）。然后再根据图5显示的四元数的计算方法得到相应的四元数数值。1234double Q0 = (short)(((short)oValueList[1]&lt;&lt;8)|oValueList[0])/32768.0;double Q1 = (short)(((short)oValueList[3]&lt;&lt;8)|oValueList[2])/32768.0;double Q2 = (short)(((short)oValueList[5]&lt;&lt;8)|oValueList[4])/32768.0;double Q3 = (short)(((short)oValueList[7]&lt;&lt;8)|oValueList[6])/32768.0; 发布IMU话题有了四元数数据之后，就可以通过定义一个IMU数据类型，并且将四元数数据赋值即可。 123456789101112ros::Publisher IMU_pub = n.advertise&lt;sensor_msgs::Imu&gt;("imu_data", 20); sensor_msgs::Imu imu_data;imu_data.header.stamp = ros::Time::now();imu_data.header.frame_id = "base_link";imu_data.orientation.x = Q1;imu_data.orientation.y = Q2;imu_data.orientation.z = Q3;imu_data.orientation.w = Q0;imu_pub.publish(imu_data); 这样就成功的发布了imu话题。然后利用imu_tools（下载地址）中的rviz_imu_plugin方法测试imu数据。测试结果如下图：]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>imu</tag>
        <tag>JY901</tag>
        <tag>MPU9250</tag>
        <tag>串口解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python notes]]></title>
    <url>%2F2018%2F04%2F16%2Fpython-notes%2F</url>
    <content type="text"><![CDATA[记录学习Python的一些常用语法，此记。 定义函数123456def power(x,n=2): s = 1 while n&gt;0: n = n -1 s = s * x return s 12345def add_end(L=None): if L is None: L = [] L.append('END') return L]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS nodelet 介绍]]></title>
    <url>%2F2018%2F04%2F09%2FROS-nodelet-%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[ROS的数据通信在graph结构中以topic,service和param的方式传输数据，数据交互存在一定的延时和阻塞。Nodelet 包就是为改善这一状况设计的， 使得多个算法运行在同一个进程中，并且算法间数据传输无需拷贝就可实现。 详见http://wiki.ros.org/nodelet。 简单的讲就是可以将以前启动的多个node捆绑在一起manager，使得同一个manager里面的topic的数据传输更快，数据通讯中roscpp采用boost shared pointer方式进行publish调用，实现zero copy。Nodelet是借助pluginlib来实现插件动态加载的，文章pluginlib特别通俗易懂的说明了pluginlib的工作原理，在理解pluginlib的基础上看nodelet会更容易。 说明nodelet的工作原理类似于pluginlib，可以参考上边所说的博客中的原理图。 实现一个nodelet插件类nodelet的实现因为借助了pluginlib的插件动态加载，因此nodelet的实现遵循pluginlib的使用规则，主要步骤如下： 创建基类，定义统一的接口。如果是基于现有的基类，则不需要这个步骤 创建nodelet插件类，继承基类，实现统一的接口 注册nodelet插件类 编译生成插件的动态链接库 将nodelet加入ROS系统 接下来，我们就根据这几个步骤来实现一个简单的nodelet功能，在开始之前需要建立一个example_pkg的功能包。 1catkin_create_pkg example_pkg 完整的功能包代码可以在github上下载。 创建基类其中基类nodelet是现有的，所以我们不需要创建基类，只需要继承nodelet基类即可。 创建nodelet插件类并注册插件类接下来我们来创建MyNodeletClass类(MyNodeletClass.h)定义，放置于目录example_pkg/include/example_pkg/下。 123456789101112#include &lt;nodelet/nodelet.h&gt;namespace example_pkg&#123; class MyNodeletClass : public nodelet::Nodelet &#123; public: virtual void onInit(); //要求构造函数不能带有参数，所以调用OnInit来完成需要初始化的工作 &#125;;&#125; 创建MyNodeletClass类实现(MyNodeletClass.cpp)，放置于目录example_pkg/src/下。 123456789101112131415161718// this should really be in the implementation (.cpp file)#include &lt;ros/ros.h&gt;#include &lt;pluginlib/class_list_macros.h&gt;#include &lt;example_pkg/MyNodeletClass.h&gt;namespace example_pkg&#123; void MyNodeletClass::onInit() &#123; NODELET_DEBUG("Initializing nodelet..."); ROS_INFO("Nodelet is Ok for test!!"); &#125;&#125;// 注册插件类PLUGINLIB_DECLARE_CLASS(example_pkg, MyNodeletClass, example_pkg::MyNodeletClass, nodelet::Nodelet) 创建插件类的描述符(nodelet_plugins.xml)，放置于目录example_pkg/plugins/下。1234567&lt;library path="lib/libexample_pkg"&gt; &lt;class name="example_pkg/MyNodeletClass" type="example_pkg::MyNodeletClass" base_class_type="nodelet::Nodelet"&gt; &lt;description&gt; This is my nodelet. &lt;/description&gt; &lt;/class&gt;&lt;/library&gt; 可以看到，这个xml文件主要描述了nodelet的动态库路径，实现类，基类，描述等信息。 编译插件的动态连接库并将插件加入ROS系统为了编译插件的功能包，需要修改CMakeLists.txt文件，修改一下内容，将插件编译为动态连接库。 1234567891011121314151617181920212223242526272829303132333435363738cmake_minimum_required(VERSION 2.8.3)project(example_pkg)## Find catkin macros and libraries## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)## is used, also find other catkin packagesfind_package(catkin REQUIRED COMPONENTS nodelet roscpp)find_package(Boost REQUIRED)catkin_package( INCLUDE_DIRS include LIBRARIES $&#123;PROJECT_NAME&#125; CATKIN_DEPENDS nodelet roscpp)############# Build ############### Specify additional locations of header files## Your package locations should be listed before other locationsinclude_directories( include $&#123;catkin_INCLUDE_DIRS&#125; $&#123;Boost_INCLUDE_DIRS&#125;)## Declare a C++ libraryadd_library($&#123;PROJECT_NAME&#125; src/MyNodeletClass.cpp)add_dependencies($&#123;PROJECT_NAME&#125; $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;catkin_LIBRARIES&#125;) 对package.xml文件进行修改，添加构建和运行依赖项(nodelet和roscpp)。 1234567891011121314&lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;&lt;build_depend&gt;nodelet&lt;/build_depend&gt;&lt;build_depend&gt;roscpp&lt;/build_depend&gt;&lt;exec_depend&gt;nodelet&lt;/exec_depend&gt;&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;&lt;!-- The export tag contains other, unspecified, tags --&gt;&lt;export&gt; &lt;!-- Other tools can request additional information be placed here --&gt; &lt;nodelet plugin="$&#123;prefix&#125;/plugins/nodelet_plugins.xml" /&gt;&lt;/export&gt; 然后我们可以通过下面的命令来查看该功能包是否编译为nodelet的插件： 1rospack plugins --attrib=plugin nodelet 如果没有问题，会出现一系列nodelet的插件路径，其中应该有上边添加的插件的路径，我的插件路径为： 12345.../opt/ros/kinetic/share/pcl_ros/pcl_nodelets.xml/home/username/catkin_turtlebot/src/example_pkg/plugins/nodelet_plugins.xml #创建的插件路径/opt/ros/kinetic/share/image_publisher/nodelet_plugins.xml... 插件的路径比较多，没有全列出来。 编写启动文件(mynodelet.launch):123456&lt;launch&gt; &lt;node pkg="nodelet" type="nodelet" name="standalone_nodelet" args="manager" output="screen"/&gt; &lt;node pkg="nodelet" type="nodelet" name="MyNodeletClass" args="load example_pkg/MyNodeletClass standalone_nodelet" output="screen"&gt; &lt;/node&gt; &lt;/launch&gt; 编译并测试根目录下编译后，运行launch文件，如果没有问题，可以看到如下结果： 1234567891011121314151617181920212223242526272829username@username-HP-ProBook-440-G3:~/catkin_turtlebot$ roslaunch example_pkg mynodelet.launch ... logging to /home/username/.ros/log/7e42af3c-3b9c-11e8-8278-a86bad0ea915/roslaunch-username-HP-ProBook-440-G3-13823.logChecking log directory for disk usage. This may take awhile.Press Ctrl-C to interruptDone checking log file disk usage. Usage is &lt;1GB.started roslaunch server http://username-HP-ProBook-440-G3:35479/SUMMARY========PARAMETERS * /rosdistro: kinetic * /rosversion: 1.12.13NODES / MyNodeletClass (nodelet/nodelet) standalone_nodelet (nodelet/nodelet)ROS_MASTER_URI=http://localhost:11311process[standalone_nodelet-1]: started with pid [13840]process[MyNodeletClass-2]: started with pid [13841][ INFO] [1523264216.026517404]: Loading nodelet /MyNodeletClass of type example_pkg/MyNodeletClass to manager standalone_nodelet with the following remappings:[ INFO] [1523264216.027989431]: waitForService: Service [/standalone_nodelet/load_nodelet] has not been advertised, waiting...[ INFO] [1523264216.071444856]: Initializing nodelet with 4 worker threads.[ INFO] [1523264216.090658134]: waitForService: Service [/standalone_nodelet/load_nodelet] is now available.[ INFO] [1523264216.092255988]: Nodelet is Ok for test!! 成功后会显示Nodelet is Ok for test!!这样，我们就完成了nodelet插件的实现和调用。]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>nodelet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正交矩阵的凯莱公式]]></title>
    <url>%2F2018%2F03%2F30%2F%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E7%9A%84%E5%87%AF%E8%8E%B1%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文主要说明一个线性代数的主要结论-正交矩阵的凯莱公式：对于任何正交矩阵 $R$, 存在一个反对称矩阵 $S$, 满足 $R=(I_3-S)^{-1}(I_3+S)$ ，此记！ 对于原点 $O$ 的一个旋转表示为：\begin{equation}P’=AP\end{equation}其中， $A$ 是一个正交矩阵。因为旋转后的向量长度不发生变化，所以 $({OP})^2=({OP’})^2$ ，并且$$P’\cdot P’-P\cdot P=0$$或者表示为：\begin{equation}(P’-P)\cdot (P’+P)=0\end{equation}其中， $P$ 是任意向量。因此可以得到 $f=P’-P$ 和 $g=P’+P$ 是正交向量。将 $f$，$g$ 和 $P$ 以列向量的形式表示，得到\begin{equation}f=(A-I)P, g=(A+I)P, f\cdot g=0\end{equation}排除 $-1$ 是矩阵 $A$ 的特征值的特例， $A+I$ 就是一个非奇异矩阵，并且\begin{equation}P=(A+I)^{-1}g\end{equation}那么，$$f=(A-I)(A+I)^{-1}g.$$假设\begin{equation}(A-I)(A+I)^{-1}=B，\star\end{equation}那么，\begin{equation}f=Bg\end{equation}假设 $B=[b_{ik}]$ ， $g_i$ 是向量 $g$ 的元素。那么，对于任意的向量 $g$ ， $f\cdot g=0$ 可以改写为：$$\sum_{i,k}(b_{ik}+b_{ki})g_ig_k=0$$那么就可以得到：对于所有的 $i,k$ ， $b_{ik}+b_{ki}=0$ 。因此矩阵$B$是反对称矩阵(skew matrix)。根据公式 $\star$ 可得：$$A-I=B(A+I)$$或者\begin{equation}(I-B)A=I+B\end{equation} 我们知道，如果矩阵$B$是一个实反对称矩阵，那么 $|B|\geq 0$ 。因此， $|B+\lambda I|$ 是关于 $\lambda$ 的带非负系数的多项式，并且除了取 $\lambda=0$ 外多项式的值不为0。也就说 $|B-I|\neq 0$ 。 可以得到结论：对于任意的 $-1$ 不是它的特征值的正交矩阵，正交矩阵可以写为：\begin{equation}A=(I-B)^{-1}(I+B)\end{equation}其中， $B$ 是反对称矩阵，以上公式成为称为凯莱公式。 参考文献： [1]Bottema O, Roth B. Theoretical Kinematics[M]. North-holland Publishing, 1979，pp: 9-10.]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[等效轴角坐标系表示法]]></title>
    <url>%2F2018%2F03%2F30%2F%E7%AD%89%E6%95%88%E8%BD%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文主要讲述等效轴角坐标系表示法的导出过程，其中涉及到罗德里格斯公式（Rodrigues’ rotation formula）的推导，此记。 首先将坐标系 $B$ 和一个已知参考坐标系 $A$ 重合。将 $B$ 绕矢量 $^A\hat{K}$ 按右手定则旋转 $\theta$ 角度。等效旋转矩阵的表示形式推导： 目标：将向量 $v=(x,y,z)$ 绕一般方向（而不是主轴方向） $\hat{r}$ （假设 $\hat{r}$ 是单位向量，如果不是，先进行单位化）旋转 $\theta$ 角度，如图1所示。 首先，将向量 $v$ 分解为两部分：平行于 $\hat{r}$ 的 $v_{||}$ 和垂直于 $\hat{r}$ 的 $v_{\bot}$，并且很容易可以得到: $$v_{||}=(v\cdot \hat{r})\hat{r}$$ $$v=v_{||}+v_{\bot}$$ $$v_{\bot}=v-v_{||}$$ $$v_{\bot}=v-(v\cdot \hat{r})\hat{r}$$ 假设，$T$ 是我们所要研究的旋转，我们需要计算 $T(v)$： \begin{align}T(v) &amp; =T(v_{||}+v_{\bot})\\&amp; = T(v_{||})+T(v_{\bot})\end{align} 因为 $v_{||}$ 平行于旋转轴 $hat{r}$ ，所以 $$T(v_{||})=v_{||}$$ 可以得到： $$T(v)=v_{||}+T(v_{\bot})$$ 其中， $T(v_{\bot})$ 是唯一需要求解的量。所以我们建立旋转平面上的两个基向量(如下图)，把 $v_{\bot}$ 作为第一个基向量，第二个基向量用 \begin{align}w &amp; =\hat{r}\times v_{\bot}\\ &amp; = \hat{r}\times v\end{align} 根据图2，我们可以得到： \begin{align}T(v_{\bot}) &amp; = v_{\bot}cos\theta+ w sin\theta\\&amp;= v_{\bot}cos\theta+(\hat{r}\times v)sin\theta\end{align} 因此， \begin{align}T(v) &amp; =v_{||}+T(v_{\bot})\\&amp;=(v\cdot \hat{r})\hat{r}+ v_{\bot}cos\theta+ (\hat{r}\times v)sin\theta\\&amp;=(v\cdot \hat{r})\hat{r}+ [v-(v\cdot \hat{r})\hat{r}]cos\theta+(\hat{r}\times v)sin\theta\\&amp;=(v\cdot \hat{r})\hat{r}+ vcos\theta- (v\cdot \hat{r})\hat{r}cos\theta+ (\hat{r}\times v)sin\theta\\&amp;=(1-cos \theta)(v\cdot \hat{r})\hat{r}+ v cos\theta+ (\hat{r}\times v)sin\theta\end{align} 得到的该式为Rodrigues公式： $$T(v)=(1-cos \theta)(v\cdot \hat{r})\hat{r}+ v cos\theta+ (\hat{r}\times v)sin\theta$$ 至此，经过变换之后的向量形式已经表示出来了。可以分别通过三个基向量来求得等效旋转矩阵的一般形式： $$p=\begin{vmatrix}1 &amp;0 &amp;0\end{vmatrix}^T $$ 将向量 $p$ 绕轴 $\hat{r}=[k_x,k_y,k_z]$ 旋转(这里为了和参考书形式相同，采用 $k$ 表示)之后的形式表示为， \begin{align}p’ &amp; =(1-cos \theta)(p\cdot \hat{r})\hat{r}+ pcos\theta+(\hat{r}\times p)sin\theta\\&amp;=(1-cos\theta)\left[\left(\begin{matrix}1\\0\\0\end{matrix}\right)\cdot \left(\begin{matrix}k_x\\k_y\\k_z\end{matrix}\right)\right]\left(\begin{matrix}k_x\\k_y\\k_z\end{matrix}\right)+\left(\begin{matrix}1\\0\\0\end{matrix}\right)cos\theta + \left[\left(\begin{matrix}k_x\\k_y\\k_z\end{matrix}\right)\times \left(\begin{matrix}1\\0\\0\end{matrix}\right)\right]sin\theta\\&amp;=\left[\begin{matrix}k_x^2(1-cos\theta)+cos\theta\\k_xk_y(1-cos\theta)+k_zsin\theta\\k_xk_z(1-cos\theta)-k_ysin\theta\end{matrix}\right]\end{align} 类似的，可以将 $q=\begin{vmatrix}0 &amp;1 &amp;0\end{vmatrix}^T$，$r=\begin{vmatrix}0 &amp;0 &amp;1\end{vmatrix}^T$ 经过旋转之后的形式表示为： $$q’=\left[\begin{matrix}k_xk_y(1-cos\theta)-k_z sin\theta\\k_y^2(1-cos\theta)+cos\theta\\k_yk_z(1-cos\theta)+k_xsin\theta\end{matrix}\right]$$ $$r’=\left[\begin{matrix}k_xk_z(1-cos\theta)+k_y sin\theta\\k_yk_z(1-cos\theta)-k_xsin\theta\\k_z^2(1-cos\theta)+cos\theta\end{matrix}\right]$$ 最后，可以得到等效旋转阵的形式： $$R_r(\theta)=\left[\begin{matrix}k_x^2v\theta+c\theta&amp;k_xk_yv\theta-k_zs\theta&amp;k_xk_zv\theta+k_ys\theta\\k_xk_yv\theta+k_zs\theta&amp;k_y^2v\theta+c\theta&amp;k_yk_zv\theta-k_xs\theta\\k_xk_zv\theta-k_ys\theta&amp;k_yk_zv\theta+k_xs\theta&amp;k_z^2v\theta+c\theta\end{matrix}\right]$$ 其中， $c\theta=cos\theta$ , $s\theta=sin\theta$ , $v\theta=1-cos\theta$ ，$\theta$ 是由右手定则确定的，即大拇指指向 $\hat{r}$ 的正方向。]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
      <tags>
        <tag>Rodrigues</tag>
        <tag>rotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server -p 4111 More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment write the latex form1the equation $$x=\sum_&#123;i=1&#125;^nx_i$$ is bla... $$\sum_{i=1}^n$$ insert figure1&#123;% img /等效轴角坐标系表示法/等效轴角坐标系表示法1.jpg 400 268 图1 旋转立体示意图 %&#125;]]></content>
      <categories>
        <category>Testing</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2F2018%2F03%2F30%2Ftest-new-post%2F</url>
    <content type="text"><![CDATA[Testing for new post]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>testing</tag>
        <tag>another tag</tag>
      </tags>
  </entry>
</search>
