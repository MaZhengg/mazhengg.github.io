<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ROS下IMU数据解析并发布-JY901（MPU9250）]]></title>
    <url>%2F2018%2F05%2F24%2FROS%E4%B8%8BIMU%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[进行ROS下机器人系统开发，需要用到IMU数据，所以需要做IMU数据解析，IMU设备是JY901（内置MPU9250）芯片，设备利用USB转TTL转换，采用了MZ-RS24T转换器，转换芯片为FT232RL，本文想要系统记录从IMU传出数据到数据转换，再到ROS下数据解析并发布IMU话题的过程及（部分）实现方法，此记。 设备连接及通信接口测试设备连接设备连接就是通过MZ-RS24T六合一转换器将TTL电平转换为USB，其中需要注意的就是将发送和接收线交叉连接，如图1所示。 windows下测试设备刚拿到设备需要确认设备是否可用，所以考虑在windows系统下测试，设备应该附带在windows的测试软件（miniIMUV4.3.11）和串口调试软件（SSCOM32），这些可以在他们的官方论坛维特智能上下载到，也可以直接到百度网盘下载，下载链接。windows下的驱动程序可以自动搜索安装就不多说了。 一些具体的测试方法在下载资料的使用说明中有具体的介绍，安装完驱动，确定能识别硬件，验证方法到我的电脑–管理–设备管理器–端口，一般显示为USB Serial Port(COM#)，然后打开miniIMUV4.3.11，可以正常显示在配置中选定的数据，说明硬件正常。 Linux下通信测试插入设备后，通过查看电脑的输入端口确定usb串口号，1ls /dev/tty* 查询到串口名为”/dev/ttyUSB0”，这样说明通信接口正常识别，后边会用的到。 IMU数据解析JY901模块是一款高精度的姿态测量模块，能够测量被测物体的姿态角度，以欧拉角或者四元素的方式输出。 模块的数据采用16进制的方式进行传输（在使用说明书中也有说明），这种方式的优点是效率高，可以用很少的字节传输需要的数据，比如一个数据1.523，如果用16进制方式传送的话，2个字节就够了，而用ascii码的话，需要5个字节，在需要大量数据传输的时候就比较浪费有限的带宽了。而16进制数据的缺点呢，就是可读性不强，不像Ascii码那样，直接就能读出数据了。 16进制数据传输的原理是这样的，先要确定数据的表示范围，然后是每个数据可用的字节数。比如角度的数据，每个角度的数据范围是±180度，而2个字节16进制数的表示范围是-32767-32768之间，那么我们就把±180的数据映射到±32768之间。假设原理的数据是x，变换以后的数据是y，那么y=x/180*32768。2个字节能表示的最小精度是1/32768*180=0.0055°，这对于角度的精度来说也够用了。下面具体讲解析的方法。在windows下先通过串口调试助手SSCOM3.2看模块的原始数据，打开相应的串口，注意要选择好正确的波特率，并且将模块的显示模式勾选为HEX显示。如图3 所示。 这里我们以只输出四元数数据为例来说明解析方法，由于这里我设置为只输出四元数数据，所以只有55 59开头的数据，例如55 59 F6 7A 94 00 9F 00 8B 23 FF。如果能看到这种以55 51, 55 52 或者55 53一直到55 59， 55 5A开头的数据，说明串口能够正常接收到数据了。根据使用说明书中的介绍，四元数的数据形式为 那么上述数据中F6 7A就是Q0的数据， 94 00就是Q1的数据，9F 00就是Q2的数据，8B 23就是Q3的数据，FF就是校验和。在Q0的数据中，F6是Q0L,7A是Q0H，那么完整的16进制数据应该是7AF6，这个16进制的数据应该如何表示为十进制的Q0数据就需要我们按照图5中的方法进行解析。 以上是在window中的串口工具读取到的数据，在Linux下我们通过serial功能包读取串口数据，下载地址Github。我们读取到的数据一般保存在一个std::string类型的变量中，比如strRead,这里我们首先将读取到的string数据转换为十六进制的字符串， 1234567891011121314std::string string_to_hex(const std::string&amp; input)&#123; static const char* const lut = "0123456789ABCDEF"; size_t len = input.length(); std::string output; output.reserve(2 * len); for (size_t i = 1; i &lt; len; ++i) &#123; const unsigned char c = input[i]; output.push_back(lut[c &gt;&gt; 4]); output.push_back(lut[c &amp; 15]); &#125; return output;&#125; 123string read;string strResult;strResult = string_to_hex(strRead); 然后我们需要根据一个数据包的报头来判断数据的开始，也就是找到55所在的位置，1data_package_start = strResult.find("55"); 然后我们将这样一组数据读取并保存到一个vector容器中，比如oValueList中123456789101112type define unsigned short WORD;vector&lt;WORD&gt; oValueList;string strResultTemp;WORD wordValue;for (int k = 0; k &lt; 8; k++)&#123; strResultTemp = strResult.substr(data_package_start + 4 +2*k, 2); wordValue = hex2int(strResultTemp); oValueList.push_back(wordValue);&#125; 利用string类的函数stbstr()，提取从55 59之后（data_package_start+4）开始的2个字符，直到校验和之前。这样我们就将原来在string类型中以十六进制形式存储的两个字符（比如F6）转存为unsigned short类型（占两个字节），并且push进vector容器中（oValueList[0]）。这样就可以通过vector容器的索引号得到四元数中各个量(Q0,Q1,Q2,Q3)的高低字节（Q0L,Q0H,Q1L,Q1H……）。然后再根据图5显示的四元数的计算方法得到相应的四元数数值。1234double Q0 = (short)(((short)oValueList[1]&lt;&lt;8)|oValueList[0])/32768.0;double Q1 = (short)(((short)oValueList[3]&lt;&lt;8)|oValueList[2])/32768.0;double Q2 = (short)(((short)oValueList[5]&lt;&lt;8)|oValueList[4])/32768.0;double Q3 = (short)(((short)oValueList[7]&lt;&lt;8)|oValueList[6])/32768.0; 发布IMU话题有了四元数数据之后，就可以通过定义一个IMU数据类型，并且将四元数数据赋值即可。 123456789101112ros::Publisher IMU_pub = n.advertise&lt;sensor_msgs::Imu&gt;("imu_data", 20); sensor_msgs::Imu imu_data;imu_data.header.stamp = ros::Time::now();imu_data.header.frame_id = "base_link";imu_data.orientation.x = Q2;imu_data.orientation.y = -Q1;imu_data.orientation.z = -Q0;imu_data.orientation.w = Q3;imu_pub.publish(imu_data); 这样就成功的发布了imu话题。然后利用imu_tools（下载地址）中的rviz_imu_plugin方法测试imu数据。测试结果如下图：]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>imu</tag>
        <tag>JY901</tag>
        <tag>MPU9250</tag>
        <tag>串口解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python notes]]></title>
    <url>%2F2018%2F04%2F16%2Fpython-notes%2F</url>
    <content type="text"><![CDATA[记录学习Python的一些常用语法，此记。 定义函数123456def power(x,n=2): s = 1 while n&gt;0: n = n -1 s = s * x return s 12345def add_end(L=None): if L is None: L = [] L.append('END') return L]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS nodelet 介绍]]></title>
    <url>%2F2018%2F04%2F09%2FROS-nodelet-%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[ROS的数据通信在graph结构中以topic,service和param的方式传输数据，数据交互存在一定的延时和阻塞。Nodelet 包就是为改善这一状况设计的， 使得多个算法运行在同一个进程中，并且算法间数据传输无需拷贝就可实现。 详见http://wiki.ros.org/nodelet。 简单的讲就是可以将以前启动的多个node捆绑在一起manager，使得同一个manager里面的topic的数据传输更快，数据通讯中roscpp采用boost shared pointer方式进行publish调用，实现zero copy。Nodelet是借助pluginlib来实现插件动态加载的，文章pluginlib特别通俗易懂的说明了pluginlib的工作原理，在理解pluginlib的基础上看nodelet会更容易。 说明nodelet的工作原理类似于pluginlib，可以参考上边所说的博客中的原理图。 实现一个nodelet插件类nodelet的实现因为借助了pluginlib的插件动态加载，因此nodelet的实现遵循pluginlib的使用规则，主要步骤如下： 创建基类，定义统一的接口。如果是基于现有的基类，则不需要这个步骤 创建nodelet插件类，继承基类，实现统一的接口 注册nodelet插件类 编译生成插件的动态链接库 将nodelet加入ROS系统 接下来，我们就根据这几个步骤来实现一个简单的nodelet功能，在开始之前需要建立一个example_pkg的功能包。 1catkin_create_pkg example_pkg 完整的功能包代码可以在github上下载。 创建基类其中基类nodelet是现有的，所以我们不需要创建基类，只需要继承nodelet基类即可。 创建nodelet插件类并注册插件类接下来我们来创建MyNodeletClass类(MyNodeletClass.h)定义，放置于目录example_pkg/include/example_pkg/下。 123456789101112#include &lt;nodelet/nodelet.h&gt;namespace example_pkg&#123; class MyNodeletClass : public nodelet::Nodelet &#123; public: virtual void onInit(); //要求构造函数不能带有参数，所以调用OnInit来完成需要初始化的工作 &#125;;&#125; 创建MyNodeletClass类实现(MyNodeletClass.cpp)，放置于目录example_pkg/src/下。 123456789101112131415161718// this should really be in the implementation (.cpp file)#include &lt;ros/ros.h&gt;#include &lt;pluginlib/class_list_macros.h&gt;#include &lt;example_pkg/MyNodeletClass.h&gt;namespace example_pkg&#123; void MyNodeletClass::onInit() &#123; NODELET_DEBUG("Initializing nodelet..."); ROS_INFO("Nodelet is Ok for test!!"); &#125;&#125;// 注册插件类PLUGINLIB_DECLARE_CLASS(example_pkg, MyNodeletClass, example_pkg::MyNodeletClass, nodelet::Nodelet) 创建插件类的描述符(nodelet_plugins.xml)，放置于目录example_pkg/plugins/下。1234567&lt;library path="lib/libexample_pkg"&gt; &lt;class name="example_pkg/MyNodeletClass" type="example_pkg::MyNodeletClass" base_class_type="nodelet::Nodelet"&gt; &lt;description&gt; This is my nodelet. &lt;/description&gt; &lt;/class&gt;&lt;/library&gt; 可以看到，这个xml文件主要描述了nodelet的动态库路径，实现类，基类，描述等信息。 编译插件的动态连接库并将插件加入ROS系统为了编译插件的功能包，需要修改CMakeLists.txt文件，修改一下内容，将插件编译为动态连接库。 1234567891011121314151617181920212223242526272829303132333435363738cmake_minimum_required(VERSION 2.8.3)project(example_pkg)## Find catkin macros and libraries## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)## is used, also find other catkin packagesfind_package(catkin REQUIRED COMPONENTS nodelet roscpp)find_package(Boost REQUIRED)catkin_package( INCLUDE_DIRS include LIBRARIES $&#123;PROJECT_NAME&#125; CATKIN_DEPENDS nodelet roscpp)############# Build ############### Specify additional locations of header files## Your package locations should be listed before other locationsinclude_directories( include $&#123;catkin_INCLUDE_DIRS&#125; $&#123;Boost_INCLUDE_DIRS&#125;)## Declare a C++ libraryadd_library($&#123;PROJECT_NAME&#125; src/MyNodeletClass.cpp)add_dependencies($&#123;PROJECT_NAME&#125; $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;catkin_LIBRARIES&#125;) 对package.xml文件进行修改，添加构建和运行依赖项(nodelet和roscpp)。 1234567891011121314&lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;&lt;build_depend&gt;nodelet&lt;/build_depend&gt;&lt;build_depend&gt;roscpp&lt;/build_depend&gt;&lt;exec_depend&gt;nodelet&lt;/exec_depend&gt;&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;&lt;!-- The export tag contains other, unspecified, tags --&gt;&lt;export&gt; &lt;!-- Other tools can request additional information be placed here --&gt; &lt;nodelet plugin="$&#123;prefix&#125;/plugins/nodelet_plugins.xml" /&gt;&lt;/export&gt; 然后我们可以通过下面的命令来查看该功能包是否编译为nodelet的插件： 1rospack plugins --attrib=plugin nodelet 如果没有问题，会出现一系列nodelet的插件路径，其中应该有上边添加的插件的路径，我的插件路径为： 12345.../opt/ros/kinetic/share/pcl_ros/pcl_nodelets.xml/home/username/catkin_turtlebot/src/example_pkg/plugins/nodelet_plugins.xml #创建的插件路径/opt/ros/kinetic/share/image_publisher/nodelet_plugins.xml... 插件的路径比较多，没有全列出来。 编写启动文件(mynodelet.launch):123456&lt;launch&gt; &lt;node pkg="nodelet" type="nodelet" name="standalone_nodelet" args="manager" output="screen"/&gt; &lt;node pkg="nodelet" type="nodelet" name="MyNodeletClass" args="load example_pkg/MyNodeletClass standalone_nodelet" output="screen"&gt; &lt;/node&gt; &lt;/launch&gt; 编译并测试根目录下编译后，运行launch文件，如果没有问题，可以看到如下结果： 1234567891011121314151617181920212223242526272829username@username-HP-ProBook-440-G3:~/catkin_turtlebot$ roslaunch example_pkg mynodelet.launch ... logging to /home/username/.ros/log/7e42af3c-3b9c-11e8-8278-a86bad0ea915/roslaunch-username-HP-ProBook-440-G3-13823.logChecking log directory for disk usage. This may take awhile.Press Ctrl-C to interruptDone checking log file disk usage. Usage is &lt;1GB.started roslaunch server http://username-HP-ProBook-440-G3:35479/SUMMARY========PARAMETERS * /rosdistro: kinetic * /rosversion: 1.12.13NODES / MyNodeletClass (nodelet/nodelet) standalone_nodelet (nodelet/nodelet)ROS_MASTER_URI=http://localhost:11311process[standalone_nodelet-1]: started with pid [13840]process[MyNodeletClass-2]: started with pid [13841][ INFO] [1523264216.026517404]: Loading nodelet /MyNodeletClass of type example_pkg/MyNodeletClass to manager standalone_nodelet with the following remappings:[ INFO] [1523264216.027989431]: waitForService: Service [/standalone_nodelet/load_nodelet] has not been advertised, waiting...[ INFO] [1523264216.071444856]: Initializing nodelet with 4 worker threads.[ INFO] [1523264216.090658134]: waitForService: Service [/standalone_nodelet/load_nodelet] is now available.[ INFO] [1523264216.092255988]: Nodelet is Ok for test!! 成功后会显示Nodelet is Ok for test!!这样，我们就完成了nodelet插件的实现和调用。]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>nodelet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正交矩阵的凯莱公式]]></title>
    <url>%2F2018%2F03%2F30%2F%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E7%9A%84%E5%87%AF%E8%8E%B1%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文主要说明一个线性代数的主要结论-正交矩阵的凯莱公式：对于任何正交矩阵 $R$, 存在一个反对称矩阵 $S$, 满足 $R=(I_3-S)^{-1}(I_3+S)$ ，此记！ 对于原点 $O$ 的一个旋转表示为：\begin{equation}P’=AP\end{equation}其中， $A$ 是一个正交矩阵。因为旋转后的向量长度不发生变化，所以 $({OP})^2=({OP’})^2$ ，并且$$P’\cdot P’-P\cdot P=0$$或者表示为：\begin{equation}(P’-P)\cdot (P’+P)=0\end{equation}其中， $P$ 是任意向量。因此可以得到 $f=P’-P$ 和 $g=P’+P$ 是正交向量。将 $f$，$g$ 和 $P$ 以列向量的形式表示，得到\begin{equation}f=(A-I)P, g=(A+I)P, f\cdot g=0\end{equation}排除 $-1$ 是矩阵 $A$ 的特征值的特例， $A+I$ 就是一个非奇异矩阵，并且\begin{equation}P=(A+I)^{-1}g\end{equation}那么，$$f=(A-I)(A+I)^{-1}g.$$假设\begin{equation}(A-I)(A+I)^{-1}=B，\star\end{equation}那么，\begin{equation}f=Bg\end{equation}假设 $B=[b_{ik}]$ ， $g_i$ 是向量 $g$ 的元素。那么，对于任意的向量 $g$ ， $f\cdot g=0$ 可以改写为：$$\sum_{i,k}(b_{ik}+b_{ki})g_ig_k=0$$那么就可以得到：对于所有的 $i,k$ ， $b_{ik}+b_{ki}=0$ 。因此矩阵$B$是反对称矩阵(skew matrix)。根据公式 $\star$ 可得：$$A-I=B(A+I)$$或者\begin{equation}(I-B)A=I+B\end{equation} 我们知道，如果矩阵$B$是一个实反对称矩阵，那么 $|B|\geq 0$ 。因此， $|B+\lambda I|$ 是关于 $\lambda$ 的带非负系数的多项式，并且除了取 $\lambda=0$ 外多项式的值不为0。也就说 $|B-I|\neq 0$ 。 可以得到结论：对于任意的 $-1$ 不是它的特征值的正交矩阵，正交矩阵可以写为：\begin{equation}A=(I-B)^{-1}(I+B)\end{equation}其中， $B$ 是反对称矩阵，以上公式成为称为凯莱公式。 参考文献： [1]Bottema O, Roth B. Theoretical Kinematics[M]. North-holland Publishing, 1979，pp: 9-10.]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[等效轴角坐标系表示法]]></title>
    <url>%2F2018%2F03%2F30%2F%E7%AD%89%E6%95%88%E8%BD%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文主要讲述等效轴角坐标系表示法的导出过程，其中涉及到罗德里格斯公式（Rodrigues’ rotation formula）的推导，此记。 首先将坐标系 $B$ 和一个已知参考坐标系 $A$ 重合。将 $B$ 绕矢量 $^A\hat{K}$ 按右手定则旋转 $\theta$ 角度。等效旋转矩阵的表示形式推导： 目标：将向量 $v=(x,y,z)$ 绕一般方向（而不是主轴方向） $\hat{r}$ （假设 $\hat{r}$ 是单位向量，如果不是，先进行单位化）旋转 $\theta$ 角度，如图1所示。 首先，将向量 $v$ 分解为两部分：平行于 $\hat{r}$ 的 $v_{||}$ 和垂直于 $\hat{r}$ 的 $v_{\bot}$，并且很容易可以得到: $$v_{||}=(v\cdot \hat{r})\hat{r}$$ $$v=v_{||}+v_{\bot}$$ $$v_{\bot}=v-v_{||}$$ $$v_{\bot}=v-(v\cdot \hat{r})\hat{r}$$ 假设，$T$ 是我们所要研究的旋转，我们需要计算 $T(v)$： \begin{align}T(v) &amp; =T(v_{||}+v_{\bot})\\&amp; = T(v_{||})+T(v_{\bot})\end{align} 因为 $v_{||}$ 平行于旋转轴 $hat{r}$ ，所以 $$T(v_{||})=v_{||}$$ 可以得到： $$T(v)=v_{||}+T(v_{\bot})$$ 其中， $T(v_{\bot})$ 是唯一需要求解的量。所以我们建立旋转平面上的两个基向量(如下图)，把 $v_{\bot}$ 作为第一个基向量，第二个基向量用 \begin{align}w &amp; =\hat{r}\times v_{\bot}\\ &amp; = \hat{r}\times v\end{align} 根据图2，我们可以得到： \begin{align}T(v_{\bot}) &amp; = v_{\bot}cos\theta+ w sin\theta\\&amp;= v_{\bot}cos\theta+(\hat{r}\times v)sin\theta\end{align} 因此， \begin{align}T(v) &amp; =v_{||}+T(v_{\bot})\\&amp;=(v\cdot \hat{r})\hat{r}+ v_{\bot}cos\theta+ (\hat{r}\times v)sin\theta\\&amp;=(v\cdot \hat{r})\hat{r}+ [v-(v\cdot \hat{r})\hat{r}]cos\theta+(\hat{r}\times v)sin\theta\\&amp;=(v\cdot \hat{r})\hat{r}+ vcos\theta- (v\cdot \hat{r})\hat{r}cos\theta+ (\hat{r}\times v)sin\theta\\&amp;=(1-cos \theta)(v\cdot \hat{r})\hat{r}+ v cos\theta+ (\hat{r}\times v)sin\theta\end{align} 得到的该式为Rodrigues公式： $$T(v)=(1-cos \theta)(v\cdot \hat{r})\hat{r}+ v cos\theta+ (\hat{r}\times v)sin\theta$$ 至此，经过变换之后的向量形式已经表示出来了。可以分别通过三个基向量来求得等效旋转矩阵的一般形式： $$p=\begin{vmatrix}1 &amp;0 &amp;0\end{vmatrix}^T $$ 将向量 $p$ 绕轴 $\hat{r}=[k_x,k_y,k_z]$ 旋转(这里为了和参考书形式相同，采用 $k$ 表示)之后的形式表示为， \begin{align}p’ &amp; =(1-cos \theta)(p\cdot \hat{r})\hat{r}+ pcos\theta+(\hat{r}\times p)sin\theta\\&amp;=(1-cos\theta)\left[\left(\begin{matrix}1\\0\\0\end{matrix}\right)\cdot \left(\begin{matrix}k_x\\k_y\\k_z\end{matrix}\right)\right]\left(\begin{matrix}k_x\\k_y\\k_z\end{matrix}\right)+\left(\begin{matrix}1\\0\\0\end{matrix}\right)cos\theta + \left[\left(\begin{matrix}k_x\\k_y\\k_z\end{matrix}\right)\times \left(\begin{matrix}1\\0\\0\end{matrix}\right)\right]sin\theta\\&amp;=\left[\begin{matrix}k_x^2(1-cos\theta)+cos\theta\\k_xk_y(1-cos\theta)+k_zsin\theta\\k_xk_z(1-cos\theta)-k_ysin\theta\end{matrix}\right]\end{align} 类似的，可以将 $q=\begin{vmatrix}0 &amp;1 &amp;0\end{vmatrix}^T$，$r=\begin{vmatrix}0 &amp;0 &amp;1\end{vmatrix}^T$ 经过旋转之后的形式表示为： $$q’=\left[\begin{matrix}k_xk_y(1-cos\theta)-k_z sin\theta\\k_y^2(1-cos\theta)+cos\theta\\k_yk_z(1-cos\theta)+k_xsin\theta\end{matrix}\right]$$ $$r’=\left[\begin{matrix}k_xk_z(1-cos\theta)+k_y sin\theta\\k_yk_z(1-cos\theta)-k_xsin\theta\\k_z^2(1-cos\theta)+cos\theta\end{matrix}\right]$$ 最后，可以得到等效旋转阵的形式： $$R_r(\theta)=\left[\begin{matrix}k_x^2v\theta+c\theta&amp;k_xk_yv\theta-k_zs\theta&amp;k_xk_zv\theta+k_ys\theta\\k_xk_yv\theta+k_zs\theta&amp;k_y^2v\theta+c\theta&amp;k_yk_zv\theta-k_xs\theta\\k_xk_zv\theta-k_ys\theta&amp;k_yk_zv\theta+k_xs\theta&amp;k_z^2v\theta+c\theta\end{matrix}\right]$$ 其中， $c\theta=cos\theta$ , $s\theta=sin\theta$ , $v\theta=1-cos\theta$ ，$\theta$ 是由右手定则确定的，即大拇指指向 $\hat{r}$ 的正方向。]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
      <tags>
        <tag>Rodrigues</tag>
        <tag>rotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2F2018%2F03%2F30%2Ftest-new-post%2F</url>
    <content type="text"><![CDATA[Testing for new post]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>testing</tag>
        <tag>another tag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server -p 4111 More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment write the latex form1the equation $$x=\sum_&#123;i=1&#125;^nx_i$$ is bla... $$\sum_{i=1}^n$$ insert figure1&#123;% img /等效轴角坐标系表示法/等效轴角坐标系表示法1.jpg 400 268 图1 旋转立体示意图 %&#125;]]></content>
      <categories>
        <category>Testing</category>
      </categories>
  </entry>
</search>
