<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>kinect彩色图和深度图对齐(三)：代码注释说明</title>
      <link href="/2019/01/24/kinect_calibrator_2/"/>
      <url>/2019/01/24/kinect_calibrator_2/</url>
      <content type="html"><![CDATA[<p>本文主要记录kinect相关的知识和对齐方法，这是第三部分，主要是代码说明，此记。</p><a id="more"></a><p>【1】XnCppWrapper.h是OpenNI的头文件，opencv/cv.h和opencv/highgui.h是opencv的一些头文件，关于opencv库内容可以参见书籍《openCV3编程入门》或OpenCV入门教程 。关于OpenNI库内容，可以看一个博客对官方文档的翻译<a href="https://blog.csdn.net/linkageworld/article/details/52621156" target="_blank" rel="noopener">OpenNI2 开发者指南</a>。</p><p>【2】四个首地址imgDepth16u，imgRGB8u， depthShow， imageShow是由cvCreateImage()函数创建的，查询百度百科了解到函数功能是创建首地址并分配存储空间，用法是：header = cvCreateImageHeader(size,depth,channels);<br>size 图像宽、高.<br>depth 图像元素的位深度，可以是下面的其中之一：<br>IPL_DEPTH_8U - 无符号8位整型<br>IPL_DEPTH_8S - 有符号8位整型<br>IPL_DEPTH_16U - 无符号16位整型<br>IPL_DEPTH_16S - 有符号16位整型<br>IPL_DEPTH_32S - 有符号32位整型<br>IPL_DEPTH_32F - 单精度浮点数<br>IPL_DEPTH_64F - 双精度浮点数<br>channels 每个元素（像素）通道数.可以是 1, 2, 3 或 4.通道是交叉存取的。<br>header是返回的数据块首地址。关于图像基础内容，可以参看博客：<a href="https://blog.csdn.net/qq_18343569/article/details/47830503" target="_blank" rel="noopener">opencv中图像基础（大小，深度，通道）</a>。</p><p>【3】OpenNI::initialize()方法。这个方法初始化所有的传感器驱动并且扫描系统中所有可用的传感器设备。所有使用OpenNI的应用程序在使用其他API之前都应该调用此方法。<br>上下文对象(context object)是OpenNI的主对象，它包括（使用OpenNI的程序的）所有状态信息，以及这个程序使用的所有产品链。同一个程序可以创建多个上下文，但是它们不可以共享信息。上下文对象在使用前必须先被初始化，这个时候所有的内置模块都被加载。<br>【4】能产生数据的产品节点叫做generator（DepthGenerator和ImageGenerator），一旦它们被创建，并不立即开始产生数据，允许程序来设置所需的配置。这能够保证一旦这些对象开始抽取数据到程序，这些数据是根据所需配置产生的。数据生成器在没有指明被要求去产生数据的话，不会自己产生数据。</p><p>【5】XnMapOutputMode是用来设定生成器的参数，GetAlternativeViewPointCap().SetViewPoint( )函数是用来调整视角的。</p><p>【6】StartGeneratingAll()函数是打开图像数据收集开关。而为了确保能取得最新的数据，在读取 Generator 的数据前，都必须要先呼叫 context 的 wait / update 这一系列的函式，来进行 node 数据的更新。<br>这系列的函示有四个：WaitAnyUpdateAll()、WaitOneUpdateAll()、WaitNoneUpdateAll() 和 WiatAndUpdateAll()。这四者都会更新 context 下所有的 node 的数据，差别只在于更新的条件：<br>WiatAndUpdateAll() 会等到所有的 node 都取得新数据后，再统一更新所有的 node 的数据；<br>WaitAnyUpdateAll() 是等到随便一个 node 有新数据时就会更新；<br>WaitOneUpdateAll() 则是等到指定的 node 有新数据时再更新；<br>WaitNoneUpdateAll() 则是不管有没有新数据就强制更新。</p><p>【7】depthGenerator.GetMetaData是获取生成器里的数据并放在depthMD缓冲器中。</p><p>【8】OpenNI支持的图像格式比较单一，需要用OpenCV进行下一步操作，则需要将DepthMetaData、ImageMetaData转换为Mat数据类型，详见博客文章。<br>memcpy指的是c和c++使用的内存拷贝函数，memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中。<br>程序中memcpy()函数的作用是将深度数据复制到imgDepth16U.imageData,图像大小为640*480,2通道（2个字节） 。这里深度数据为什么是两个字节，相信都有疑惑。经查询资料了解到，Kinect的深度图像数据含有两种格式，两种格式都是用两个字节来保存一个像素的深度值，而两方式的差别为：<br>（1）唯一表示深度值：那么像素的低12位表示一个深度值，高4位未使用；</p><p>（2）既表示深度值又含有游戏者ID：Kinect SDK具有分析深度数据和探测人体或者游戏者轮廓的功能，它一次能够识别多达6个游戏者。SDK为每一个追踪到的游戏者编号作为索引。而这个方式中，像素值的高13位保存了深度值，低三位保存用户序号，7 (0000 0111)这个位掩码能够帮助我们从深度数据中获取到游戏者索引值（这个编程将在下一节）。</p><p>应用程序可以使用深度数据流中的深度数据来支持各种各样的用户特性，如追踪用户的运动并在程序中识别和忽略背景物体的信息等。</p><p>【9】cvConvertScale()函数作用是使用线形变换转换数据，255/4096比例压缩，转换到0-255范围。至于为什么，应该是电脑屏幕的正常显示（也即opencv的图像显示）的要求吧。</p><p>【10】cvWaitKey()函数的功能是不断刷新图像，频率时间为delay，单位为ms。返回值为当前键盘按键值。经查询，键值为27的是电脑键盘上的ESC退出键。</p><p>【11】最后调用CV库中的函数关闭窗口，释放内存空间。用StopGeneratingAll()函数关闭数据收集开关，用context.Shutdown()方法关闭所有驱动并且正确地清除所有。 </p><p>整合自以下博客：</p><p>[1]<a href="https://blog.csdn.net/qq_36355662/article/details/76747290" target="_blank" rel="noopener">https://blog.csdn.net/qq_36355662/article/details/76747290</a><br>[2]<a href="https://blog.csdn.net/zouxy09/article/details/8146719" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8146719</a> </p>]]></content>
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
            <tag> kinect </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kinect彩色图和深度图对齐(二)</title>
      <link href="/2019/01/24/kinect_calibrator_1/"/>
      <url>/2019/01/24/kinect_calibrator_1/</url>
      <content type="html"><![CDATA[<p>本文主要记录kinect相关的知识和对齐方法，这是第二部分，此记。</p><a id="more"></a><p>kinect驱动安装在上一篇已经完成，测试没问题，那么现在开始kinect彩色图和深度图的对齐工作。</p><h1 id="Kinect彩色图和红外图获取"><a href="#Kinect彩色图和红外图获取" class="headerlink" title="Kinect彩色图和红外图获取"></a>Kinect彩色图和红外图获取</h1><p>Kinect的深度图实际上是由IR相机（红外相机）形成的，因此，本质上做的是彩色图和红外图像的对齐。因此，需要先获取彩色图像和红外图像，图像的获取方法应该是多样的，比如通过ros利用freenect功能包启动kinect，通过image_view订阅相关话题显示彩色图和红外图像，问题是我在订阅红外图像的时候总是不显示，全是黑色一片，只订阅红外图像话题仍然存在这个问题，尝试过很多方法都不行，考虑到一个原因就是kinect v1不能同时显示彩色图像和红外图像，但是在rviz中显示就没有问题，很费解！</p><p>此方法行不通后，考虑自己写代码实现，参考了一些资料后，成功实现彩色图像和红外图像的采集保存。代码及相应的配置文件如下，为保证文章的连续性，代码的说明放在另一篇幅中（<a href="">链接</a>）。</p><p>main.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//【1】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;XnCppWrapper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv/cv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv/highgui.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图像的宽度和高度，注意顺序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Depth_Width 640</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Depth_Height 480</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rgb_Width 640</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rgb_Height 480</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ir_Width 640</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ir_Height 480</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckOpenNIError</span><span class="params">( XnStatus result, <span class="built_in">string</span> status )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( result != XN_STATUS_OK )</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; status &lt;&lt; <span class="string">" Error: "</span> &lt;&lt; xnGetStatusString( result ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XnStatus result = XN_STATUS_OK;</span><br><span class="line">    xn::DepthMetaData depthMD;</span><br><span class="line">    xn::ImageMetaData imageMD;</span><br><span class="line">    xn::IRMetaData irMD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//OpenCV</span></span><br><span class="line">    <span class="comment">//IplImage* cvCreateImage(CvSize cvSize(int width, int height), </span></span><br><span class="line">    <span class="comment">//int depth, int channels);</span></span><br><span class="line">    <span class="comment">//如果我们要创建一个宽为360,高为640的3通道图像（RGB图像），</span></span><br><span class="line">    <span class="comment">//可以采用如下语句：</span></span><br><span class="line">    <span class="comment">//IplImage* img=cvCreateImage( cvSize(360,640), IPL_DEPTH_8U,3 );</span></span><br><span class="line"></span><br><span class="line">    IplImage*  imgDepth16u=cvCreateImage(cvSize(Depth_Width,Depth_Height),</span><br><span class="line">    IPL_DEPTH_16U,<span class="number">1</span>);</span><br><span class="line">    IplImage* imgRGB8u=cvCreateImage(cvSize(Rgb_Width,Rgb_Height),</span><br><span class="line">    IPL_DEPTH_8U,<span class="number">3</span>);</span><br><span class="line">    IplImage* imgIR16u = cvCreateImage(cvSize(Ir_Width,Ir_Height),</span><br><span class="line">    IPL_DEPTH_16U,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    IplImage*  depthShow=cvCreateImage(cvSize(Depth_Width,Depth_Height),</span><br><span class="line">    IPL_DEPTH_8U,<span class="number">1</span>);</span><br><span class="line">    IplImage* imageShow=cvCreateImage(cvSize(Rgb_Width,Rgb_Height),</span><br><span class="line">    IPL_DEPTH_8U,<span class="number">3</span>);</span><br><span class="line">    IplImage* irShow = cvCreateImage(cvSize(Ir_Width,Ir_Height),</span><br><span class="line">    IPL_DEPTH_8U,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create window</span></span><br><span class="line">    cvNamedWindow(<span class="string">"depth"</span>,<span class="number">1</span>);</span><br><span class="line">    cvNamedWindow(<span class="string">"image"</span>,<span class="number">1</span>);</span><br><span class="line">    cvNamedWindow(<span class="string">"ir"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span> key=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】</span></span><br><span class="line">    <span class="comment">// context</span></span><br><span class="line">    xn::Context context;</span><br><span class="line">    result = context.Init();</span><br><span class="line">    CheckOpenNIError( result, <span class="string">"initialize context"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creategenerator</span></span><br><span class="line">    xn::DepthGenerator depthGenerator;</span><br><span class="line">    result = depthGenerator.Create( context );</span><br><span class="line">    CheckOpenNIError( result, <span class="string">"Create depth generator"</span> );</span><br><span class="line">    xn::ImageGenerator imageGenerator;</span><br><span class="line">    result = imageGenerator.Create( context );</span><br><span class="line">    CheckOpenNIError( result, <span class="string">"Create image generator"</span> );</span><br><span class="line">    xn::IRGenerator irGenerator;</span><br><span class="line">    result = irGenerator.Create( context );</span><br><span class="line">    CheckOpenNIError( result, <span class="string">"Create ir generator"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】</span></span><br><span class="line">    <span class="comment">//map mode</span></span><br><span class="line">    XnMapOutputMode mapMode;</span><br><span class="line">    mapMode.nXRes = <span class="number">640</span>;</span><br><span class="line">    mapMode.nYRes = <span class="number">480</span>;</span><br><span class="line">    mapMode.nFPS = <span class="number">30</span>;</span><br><span class="line">    result = depthGenerator.SetMapOutputMode( mapMode );</span><br><span class="line">    result = imageGenerator.SetMapOutputMode( mapMode );</span><br><span class="line">    result = irGenerator.SetMapOutputMode( mapMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】</span></span><br><span class="line">    <span class="comment">// correct view port</span></span><br><span class="line">    depthGenerator.GetAlternativeViewPointCap().SetViewPoint( imageGenerator );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】</span></span><br><span class="line">    <span class="comment">//read data</span></span><br><span class="line">    result = context.StartGeneratingAll();</span><br><span class="line">    <span class="comment">//【6】</span></span><br><span class="line">    result = context.WaitNoneUpdateAll();</span><br><span class="line">    <span class="keyword">long</span> currentFrame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( (key!=<span class="number">27</span>) &amp;&amp; !(result = context.WaitNoneUpdateAll( ))  )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//get meta data</span></span><br><span class="line">        depthGenerator.GetMetaData(depthMD);</span><br><span class="line">        imageGenerator.GetMetaData(imageMD);</span><br><span class="line">        irGenerator.GetMetaData(irMD);</span><br><span class="line">        <span class="built_in">stringstream</span> str;</span><br><span class="line">        str &lt;&lt; <span class="string">"stamp"</span> &lt;&lt; currentFrame &lt;&lt; <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="comment">//【7】</span></span><br><span class="line">        <span class="comment">//OpenCV output</span></span><br><span class="line">        <span class="built_in">memcpy</span>(imgDepth16u-&gt;imageData,depthMD.Data(),<span class="number">640</span>*<span class="number">480</span>*<span class="number">2</span>);</span><br><span class="line">        cvConvertScale(imgDepth16u,depthShow,<span class="number">255</span>/<span class="number">4096.0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(imgIR16u-&gt;imageData,irMD.Data(),<span class="number">640</span>*<span class="number">480</span>*<span class="number">2</span>);</span><br><span class="line">        cvConvertScale(imgIR16u,irShow,<span class="number">1</span>,<span class="number">0</span>);;</span><br><span class="line">        <span class="built_in">memcpy</span>(imgRGB8u-&gt;imageData,imageMD.Data(),<span class="number">640</span>*<span class="number">480</span>*<span class="number">3</span>);</span><br><span class="line">        cvCvtColor(imgRGB8u,imageShow,CV_RGB2BGR);</span><br><span class="line">        cvShowImage(<span class="string">"depth"</span>, depthShow);</span><br><span class="line">        cvShowImage(<span class="string">"image"</span>,imageShow);</span><br><span class="line">        cvShowImage(<span class="string">"ir"</span>,irShow);</span><br><span class="line">        cvShowImage(<span class="string">"ir"</span>,irShow);</span><br><span class="line">        <span class="keyword">if</span> (currentFrame % <span class="number">30</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cvSaveImage(<span class="string">"rgb.jpg"</span>,imageShow);</span><br><span class="line">            cvSaveImage(<span class="string">"depth.png"</span>,depthShow);</span><br><span class="line">            cvSaveImage(<span class="string">"ir.png"</span>,irShow);</span><br><span class="line">        &#125;</span><br><span class="line">        key=cvWaitKey(<span class="number">20</span>);</span><br><span class="line">        currentFrame++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//destroy</span></span><br><span class="line">    cvDestroyWindow(<span class="string">"depth"</span>);</span><br><span class="line">    cvDestroyWindow(<span class="string">"image"</span>);</span><br><span class="line">    cvDestroyWindow(<span class="string">"ir"</span>);</span><br><span class="line">    cvReleaseImage(&amp;imgDepth16u);</span><br><span class="line">    cvReleaseImage(&amp;imgRGB8u);</span><br><span class="line">    cvReleaseImage(&amp;imgIR16u);</span><br><span class="line">    cvReleaseImage(&amp;depthShow);</span><br><span class="line">    cvReleaseImage(&amp;imageShow);</span><br><span class="line">    cvReleaseImage(&amp;irShow);</span><br><span class="line">    context.StopGeneratingAll();</span><br><span class="line">    context.Release();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hellokinect)</span><br><span class="line"> <span class="comment"># 寻找OpenCV库</span></span><br><span class="line"> <span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"> <span class="comment"># 添加头文件</span></span><br><span class="line"> <span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"> <span class="comment"># 包含OpenNI库</span></span><br><span class="line"> <span class="keyword">include_directories</span> (<span class="string">"/usr/include/ni/"</span> )</span><br><span class="line"> <span class="keyword">add_executable</span>(hellokinect main.cpp)</span><br><span class="line"> <span class="keyword">target_link_libraries</span>( hellokinect OpenNI <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="创建图像包含三个元素："><a href="#创建图像包含三个元素：" class="headerlink" title="创建图像包含三个元素："></a>创建图像包含三个元素：</h3><ul><li>图像的大小</li><li>图像的深度</li><li>图像的通道</li></ul><p>depth 图像元素的位深度，可以是下面的其中之一：</p><table><thead><tr><th>位深度</th><th>取值范围</th></tr></thead><tbody><tr><td>IPL_DEPTH_8U - 无符号8位整型</td><td>0–255</td></tr><tr><td>IPL_DEPTH_8S - 有符号8位整型</td><td>-128–127</td></tr><tr><td>IPL_DEPTH_16U - 无符号16位整型</td><td>0–65535</td></tr><tr><td>IPL_DEPTH_16S - 有符号16位整型</td><td>-32768–32767</td></tr><tr><td>IPL_DEPTH_32S - 有符号32位整型</td><td>0–65535</td></tr><tr><td>IPL_DEPTH_32F - 单精度浮点数</td><td>0.0–1.0</td></tr><tr><td>IPL_DEPTH_64F - 双精度浮点数</td><td>0.0–1.0</td></tr></tbody></table><h3 id="位深度转换原理"><a href="#位深度转换原理" class="headerlink" title="位深度转换原理"></a>位深度转换原理</h3><p>如上，给出图像的位深度及其取值范围后，我们不难理解，要转换位深度本质上就是对原深度下的数据做线性变换，使原位深度下的最小值和最大值分别对应转换后位深度下的最小值和最大值。实现上述线性变换，我们可以用opencv库函数cvConvertScale。</p><h3 id="图像的通道"><a href="#图像的通道" class="headerlink" title="图像的通道"></a>图像的通道</h3><p>比较通俗易懂的解释是：灰度图的通道数为1，彩色图的通道为3。基本上，描述一个像素点，如果是灰度，那么只需要一个数值来描述它，就是单通道。如果一个像素点，有RGB三种颜色来描述它，就是三通道。</p><h1 id="Kinect彩色图和深度图对准"><a href="#Kinect彩色图和深度图对准" class="headerlink" title="Kinect彩色图和深度图对准"></a>Kinect彩色图和深度图对准</h1><h2 id="MATLAB对准方法"><a href="#MATLAB对准方法" class="headerlink" title="MATLAB对准方法"></a>MATLAB对准方法</h2><p>将得到的彩色图像和红外图像分为两组，然后利用MATLAB的stereoCameraCalibrator工具箱，输入两组图像，然后点击calibrate即可得到两个相机的坐标变换旋转矩阵$R$和平移矩阵$T$，MATLAB得到的矩阵$\hat{R}$需要转置后才是旋转矩阵$R$.<a href="https://ww2.mathworks.cn/help/vision/ug/stereo-camera-calibrator-app.html" target="_blank" rel="noopener">stereoCameraCalibrator工具箱链接</a></p><h1 id="Kinect彩色图和深度图对准理论方法"><a href="#Kinect彩色图和深度图对准理论方法" class="headerlink" title="Kinect彩色图和深度图对准理论方法"></a>Kinect彩色图和深度图对准理论方法</h1><p>kinect RGB的内参:<br>$$K_{rgb} =\left[\begin{array}{ccc}<br>f_{x_rgb} &amp; 0 &amp; c_{x_rgb}\<br>0 &amp; f_{y_rgb} &amp; c_{y_rgb}\<br>0 &amp; 0 &amp; 1<br>\end{array}\right] =\left[\begin{array}{ccc}<br>522.955354 &amp; 0.000000   &amp; 327.140468\<br>0.000000   &amp; 523.763483 &amp; 218.630165\<br>0.000000   &amp; 0.000000   &amp; 1.000000<br>\end{array}\right]<br>$$<br>因此，对于各自相机坐标系下的齐次的三维点($P=[X,Y,Z,1]^T$)到各自图片上齐次表示的像素坐标($p=[u,v,1]^T$)的映射关系如下：</p><p>对彩色相机而言，有：<br>\begin{equation}<br>Z_{rgb}<em>p_{rgb} = K_{rgb}</em>[I|0]P_{rgb}<br>\end{equation}</p><p>展开如下，<br>\begin{equation}<br>\begin{aligned}<br>Z_{rgb}<em>\left[\begin{array}{c}<br>u_{rgb}\v_{rgb}\1<br>\end{array}\right]&amp; = \left[<br>\begin{array}{c}<br>f_{x_rgb}</em>X_{rgb}+c_{x_rgb}<em>Z_{rgb}\f_{y_rgb}</em>Y_{rgb}+c_{y_rgb}<em>Z_{rgb}\Z_{rgb}<br>\end{array}\right] \&amp; =\left[<br>\begin{array}{cccc}<br>f_{x_rgb} &amp; 0 &amp; c_{x_rgb} &amp; 0\<br>0 &amp; f_{y_rgb} &amp; c_{y_rgb} &amp; 0\<br>0 &amp; 0 &amp; 1&amp; 0<br>\end{array}\right]</em>\left[<br>\begin{array}{c}<br>X_{rgb}\Y_{rgb}\Z_{rgb}\1<br>\end{array}\right]<br>\end{aligned}<br>\end{equation}</p><p>其中，齐次坐标$P_{rgb} = [X_{rgb},Y_{rgb},Z_{rgb} 1]^T$我们可以用非齐次坐标$\bar{P_{rgb}}=[X_{rgb},Y_{rgb},Z_{rgb}]^T$来表示，应有如下的形式：<br>\begin{equation}<br>Z_{rgb}<em>p_{rgb} = K_{rgb}</em>\bar{P_{rgb}}<br>\end{equation}</p><p>kinect Depth(ir)的内参:<br>\begin{equation}<br>K_{ir} =\left[\begin{array}{ccc}<br>f_{x_ir} &amp; 0 &amp; c_{x_ir}\<br>0 &amp; f_{y_ir} &amp; c_{y_ir}\<br>0 &amp; 0 &amp; 1<br>\end{array}\right] =\left[\begin{array}{ccc}<br>605.290291 &amp; 0.000000   &amp; 333.064832\<br>0.000000   &amp; 606.360112 &amp; 205.426105\<br>0.000000   &amp; 0.000000   &amp; 1.000000<br>\end{array}\right]<br>\end{equation}</p><p>同理，可得到深度相机的映射公式：<br>\begin{equation}<br>Z_{ir}<em>p_{ir} = K_{ir}</em>\bar{P_{ir}}<br>\end{equation}</p><p>针对于同一幅棋盘的外参(MATLAB的cameraCalibrator可以实现内/外参标定):</p><p>彩色相机：$R_{rgb}$和$T_{rgb}$</p><p>深度相机：$R_{ir}$和$T_{ir}$</p><p>因此，两个相机有如下刚体变换关系：<br>[R_{ir2rgb} = R_{rgb}<em>R_{ir}^{-1}]<br>[T_{ir2rgb} = T_{rgb} - R_{ir2rgb}</em>T_{ir}]</p><p>对于非齐次坐标表示的各自相机坐标系下的三维点$\bar{P_{rgb}}$和$\bar{P_{ir}}$来说，有如下关系：<br>[\bar{P_{rgb}} = R_{ir2rgb}*\bar{P_{ir}} + T_{ir2rgb}]</p><p>最后，我们可以得到如下公式：<br>[Z_{rgb}<em>p_{rgb} = K_{rgb}</em>R_{ir2rgb}<em>K_{ir}^{-1}</em>Z_{ir}<em>p_{ir}+K_{rgb}</em>T_{ir2rgb}]</p><p>这样就把$p_{rgb}$和$p_{ir}$联系起来了。</p><p>为了简化表示，我们令：<br>[R = K_{rgb}<em>R_{ir2rgb}</em>K_{ir}^{-1}]<br>[T = K_{rgb}*T_{ir2rgb}]</p><p>则有，<br>[Z_{rgb}<em>p_{rgb} = R</em>Z_{ir}*p_{ir}+T]</p>]]></content>
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
            <tag> kinect </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kinect彩色图和深度图对齐(一)</title>
      <link href="/2019/01/23/kinect_calibrator/"/>
      <url>/2019/01/23/kinect_calibrator/</url>
      <content type="html"><![CDATA[<p>本文主要记录kinect相关的知识和对齐方法，这是第一部分，此记。</p><a id="more"></a><h1 id="深度相机成像方法简介"><a href="#深度相机成像方法简介" class="headerlink" title="深度相机成像方法简介"></a>深度相机成像方法简介</h1><p>深度相机就是可以获取场景中物体距离摄像头物理距离的相机。深度相机通常由多种镜头和光学传感器组成，根据测量原理不同，主流的深度相机一般分为以下几种方法：飞行时间法（ToF）、结构光法、双目立体视觉法。</p><img src="/2019/01/23/kinect_calibrator/ToF.jpeg" width="320" height="150" title="图1 ToF原理示意图"><p>飞行时间是从Time of Flight直译过来的，简称TOF。其测距原理是通过连续发射经过调制的特定频率的光脉冲（一般为不可见光）到被观测物体上，然后接收从物体反射回去的光脉冲，通过探测光脉冲的飞行（往返）时间来计算被测物体离相机的距离。微软的Kinect V2采用的就是ToF方案。</p><img src="/2019/01/23/kinect_calibrator/结构光.jpeg" width="325" height="267" title="图2 结构光原理示意图"><p>结构光法就是使用提前设计好的具有特殊结构的图案（比如离散光斑、条纹光、编码结构光等），将图案投影到三维空间物体表面上，使用另外一个相机观察在三维物理表面成像的畸变情况。如果结构光图案投影在该物体表面是一个平面，那么观察到的成像中结构光的图案就和投影的图案类似，没有变形，只是根据距离远近产生一定的尺度变化。但是，如果物体表面不是平面，那么观察到的结构光图案就会因为物体表面不同的几何形状而产生不同的扭曲变形，而且根据距离的不同而不同，根据已知的结构光图案及观察到的变形，就能根据算法计算被测物的三维形状及深度信息。微软的Kinect V1采用的就是基于结构光的光编码方案。</p><p>结构光法优缺点总结</p><p>根据前面的原理介绍，我们总结一下基于结构光法深度相机的优缺点。</p><p>优点</p><p>1)、由于结构光主动投射编码光，因而非常适合在光照不足（甚至无光）、缺乏纹理的场景使用。</p><p>2)、结构光投影图案一般经过精心设计，所以在一定范围内可以达到较高的测量精度。</p><p>3)、技术成熟，深度图像可以做到相对较高的分辨率。</p><p>缺点</p><p>1）、室外环境基本不能使用。这是因为在室外容易受到强自然光影响，导致投射的编码光被淹没。增加投射光源的功率可以一定程度上缓解该问题，但是效果并不能让人满意。</p><p>2）、测量距离较近。物体距离相机越远，物体上的投影图案越大，精度也越差（想象一下手电筒照射远处的情景），相对应的测量精度也越差。所以基于结构光的深度相机测量精度随着距离的增大而大幅降低。因而，往往在近距离场景中应用较多。</p><p>3)、容易受到光滑平面反光的影响。</p><img src="/2019/01/23/kinect_calibrator/双目.png" width="370" height="228" title="图3 双目原理示意图"><p>双目立体视觉法的原理和人眼类似，通过计算空间中同一个物体在两个相机成像的视差就可以根据如下三角关系计算得到物体离相机的距离。</p><h1 id="Kinect简介"><a href="#Kinect简介" class="headerlink" title="Kinect简介"></a>Kinect简介</h1><img src="/2019/01/23/kinect_calibrator/kinect.png" width="371" height="228" title="图4 kinect功能示意图"><p>Kinect有三个镜头，中间的镜头是RGB彩色摄影机，用来采集彩色图像。左右两边镜头则分别为红外线发射器和红外线CMOS摄影机所构成的3D结构光深度感应器，用来采集深度数据（场景中物体到摄像头的距离），Kinect采用了“光编码”的方式，读取投射的红外线光谱，通过反射斑点（称为散斑）的变形来取得纵向的深度的信息。彩色摄像头最大支持1280×960分辨率成像，红外摄像头最大支持640×480成像，最高输出速度为30fps。Kinect还搭配了追焦技术，底座马达会随着对焦物体移动跟着转动。Kinect也内建阵列式麦克风，由四个麦克风同时收音，比对后消除杂音，并通过其采集声音进行语音识别和声源定位。</p><h2 id="Kinect-V1的Kinect-V2的对比"><a href="#Kinect-V1的Kinect-V2的对比" class="headerlink" title="Kinect V1的Kinect V2的对比"></a>Kinect V1的Kinect V2的对比</h2><p>Kinect v1深度相机拥有一个RGB彩色摄像头，一个红外线CMOS摄像机和一个红外发射器。相机的红外线CMOS摄像机和红外发射器以左右水平的方式分布。该相机采用的是以结构光为基础进行改进后的光编码（Light Coding）技术获得物体的深度信息。</p><p>Kinect V2采用的是「Time of Flight(TOF)」的方式，通过从投射的红外线反射后返回的时间来取得Depth信息。Depth传感器看不到外观，不过Color Camera旁边是红外线Camera(左)和投射脉冲变调红外线的Porjector（右）。 </p><h1 id="Kinect-驱动简介-非官方和官方开发包的优缺点"><a href="#Kinect-驱动简介-非官方和官方开发包的优缺点" class="headerlink" title="Kinect 驱动简介:非官方和官方开发包的优缺点"></a>Kinect 驱动简介:非官方和官方开发包的优缺点</h1><h2 id="官方SDK："><a href="#官方SDK：" class="headerlink" title="官方SDK："></a>官方SDK：</h2><p>长处：</p><p>提供了音频支持、调整倾角的转动电机、在全身跟踪骨骼跟踪方面：非标准姿势检測（相对于OpenNi的投降姿势…），头部、手、脚、锁骨检測以及关节遮挡等细节上的处理更为仔细（但精度是否更高还不能确定）。此外，支持多传感器（多台Kinect）；</p><p>缺点：</p><p>微软对非商业使用的限制。此外，未提供手势识别和跟踪功能，未实现RGB图像/深度图像的互对齐，仅仅是提供了对个体坐标系的对齐。在全身骨骼跟踪中，SDK仅仅计算了关节的位置，并未得出其旋转角度。从可移植的角度来看，SDK beta仅仅能用于Kinect/Win7平台，而OpenNi还至少支持华硕的WAVI Xtion体感设备，今后支持的硬件平台还可能很多其它。相比較而言SDK beta不支持Unity3D游戏引擎、不支持记录/回放数据写入磁盘、不支持原始红外视频数据流、也不支持像OpenNi一样的角色入场和出场的事件响应机制。</p><h2 id="非官方OpenNI-NITE："><a href="#非官方OpenNI-NITE：" class="headerlink" title="非官方OpenNI/NITE："></a>非官方OpenNI/NITE：</h2><p>长处：</p><p>可用于商业开发、包括手势识别和跟踪功能、可自己主动对齐深度图像和RGB图像，全身跟踪、关节旋转角度计算、看起来性能较好、已有众多游戏产品应用、支持记录/回放数据写入磁盘、支持原始红外视频数据流、支持角色入场和出场的事件响应机制。支持Primesense和华硕的WAVI Xtion硬件平台和windows、Linux和Mac等软件平台。自带的代码全面支持Unity3D游戏引擎。</p><p>缺点：</p><p>未提供音频功能、不支持调整倾角的转动电机、在全身跟踪骨骼跟踪方面：无法跟踪头部、手、脚和锁骨的旋转动作，须要标准姿势检測（即著名的投降姿势…），关节遮挡等细节上的处理似乎存在算法bug。不能自己主动安装并识别Kinect多机环境。安装过程较为繁琐，特别是NITE还要申请开发证书编码。OpenNi也没有提供可用视频和深度图输入的事件触发机制（但OpenNI提供了类似功能的函数可使用，尽管不是回调函数，可是也非常好用）。</p><p>总结：</p><p>OpenNI最大的优势就是同意跨平台多设备，以及商业应用。但从原始数据的採集和预处理技术上看，微软的SDK似乎更稳定一些，况且还提供了不错的骨骼和语音支持。对于部分身体部位识别方面的功能，SDKbeta没有提供局部识别和跟踪，这须要自己的兴许开发（至少在相当一段时期内微软可能都不会提供此类功能）。OpenNi/NITE尽管提供了手势识别和跟踪，然而在全身骨骼姿势识别和跟踪上还要很多其它借鉴微软的产品。</p><p>因此，依照眼下在社区中的表现，SDK beta和OpenNi/NITE孰优孰劣还真无法一下子确定。并且随着越来越多的开发人员增加微软这一方，SDK beta的普及可能会更快，但在更高层次的应用上，对二者的选用往往是须要一定智慧的。</p><h1 id="Kinect驱动安装"><a href="#Kinect驱动安装" class="headerlink" title="Kinect驱动安装"></a>Kinect驱动安装</h1><p>刚开始使用kinect首先需要安装kinect驱动，我的机器环境是：Ubuntu16.04 kinect V1, 驱动分别是：openni/NITE/Sensor这三个包的版本必须匹配才能正常运行，版本号分别是：</p><p>OpenNI-Bin-Dev-Linux-x64-v1.5.7.10.tar</p><p>NITE-Bin-Linux-x64-v1.5.2.23.tar</p><p>SensorKinect093-Bin-Linux-x64-v5.1.2.1</p><p>可以在网盘下载，链接: <a href="https://pan.baidu.com/s/1wFtWG5efIocx2Xb-xbbf2g" target="_blank" rel="noopener">驱动下载</a> 提取码: 7ckj。</p><p>【Tips】</p><p>这三个软件包的安装要注意顺序：先安装openni，再安装Sensor，最后安装NITE。</p><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>1,OpenNI<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> /Home/Downloads/OpenNI-Bin-Dev-Linux-x64-v1.5.7.10</span><br><span class="line"><span class="variable">$sudo</span> ./install.sh</span><br></pre></td></tr></table></figure></p><p>安装完成后会有成功提示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">copying</span><br><span class="line">shared libraries...OK</span><br><span class="line">....</span><br><span class="line">....    </span><br><span class="line">***</span><br><span class="line">DONE ***</span><br></pre></td></tr></table></figure></p><p>2,SensorKinect和NITI</p><p>安装方法相似，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /Home/Downloads/Sensor-Bin-Linux-x64-v5.1.2.1</span><br><span class="line">$ sudo ./install.sh</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /Home/Downloads/NITE-Bin-Linux-x64-v1.5.2.23</span><br><span class="line">$ sudo ./install.sh</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>安装完成后同样会有DONE ×××类似的成功提示。</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>测试安装成功与否的方法是采用OpenNI自带的例程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /Home/Downloads/OpenNI-Bin-Dev-Linux-x64-v1.5.7.10/Samples/Bin/x64-Release</span><br><span class="line">$ ./NiViewer</span><br></pre></td></tr></table></figure></p><p>如果出现以下kinect画面则配置成功。<br><img src="/2019/01/23/kinect_calibrator/测试画面.png" width="576" height="324" title="图4 kinect运行NiViewer测试画面"></p><p>另外可以带-u参数卸载这些软件包重新安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> ./install.sh -u</span><br></pre></td></tr></table></figure></p><p>但是NITE里有专门的uninstall.sh可以运行它来卸载。</p><h2 id="ROS环境下的测试"><a href="#ROS环境下的测试" class="headerlink" title="ROS环境下的测试"></a>ROS环境下的测试</h2><p>如果你安装了ROS，那么还可以通过安装freenect功能包来测试kinect<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/ros-drivers/freenect_stack.git </span><br><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/</span><br><span class="line">$ catkin_make</span><br><span class="line">$ rospack profile</span><br><span class="line">$ roslaunch freenect_launch freenect.launch</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
            <tag> kinect </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>卡尔曼滤波推导</title>
      <link href="/2019/01/04/KalmanFilter/"/>
      <url>/2019/01/04/KalmanFilter/</url>
      <content type="html"><![CDATA[<p>本文主要记录卡尔曼滤波的推导过程，此记。</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>卡尔曼滤波，首先说一下，为什么要用“滤波”这个词？</p><p>从带有噪声的数据中找到“最优估计”的过程就是“过滤”掉噪声的过程。<br>卡尔曼滤波是最好的线性估计方法。</p><h1 id="建立系统数学模型"><a href="#建立系统数学模型" class="headerlink" title="建立系统数学模型"></a>建立系统数学模型</h1><p>在实际应用中，我们可以将物理系统的运行过程看作是一个状态转换过程，卡尔曼滤波将状态空间理论引入到对物理系统的数学建模过程中来，其假设系统状态可以用$n$维空间的一个向量$X\in R^n$来表示。为了描述方便，我们作以下假设：1物理系统的状态转换过程可以描述为一个离散时间的随机过程;2系统状态受控制输入的影响；3系统状态及观测过程都不可避免受噪声影响;4对系统状态是非直接可观测的。</p><p> 在以上假设前提下，定义系统状态变量为$x_k\in R^n$，系统控制输入为$u_k$，系统过程激励噪声为$w_k$,可得出系统的状态随机差分方程为：<br> $$x_k=Ax_{k-1}+Bu_{k-1}+w_{k-1}\tag{1}$$</p><p> 定义观测变量$z_k\in R^m$，观测噪声为$v_k$，得到量测方程：<br> $$z_k=Hx_k+v_k\tag{2}$$</p><p> 假设$w_k,v_k$为相互独立，正态分布的白色噪声，过程激励噪声协方差矩阵为$Q$，观测噪声协方差矩阵为$R$，即：<br> $$p(w)\sim N(0,Q)\tag{3}$$<br> $$p(v)\sim N(0,R)\tag{4}$$</p><p> $A,B,H$我们统称为状态变换矩阵，是状态变换过程中的调整系数，是从建立的系统数学模型中导出来的，这儿我们假设它们是常数。</p><h1 id="滤波器计算原型"><a href="#滤波器计算原型" class="headerlink" title="滤波器计算原型"></a>滤波器计算原型</h1><p> 从建立的系统数学模型出发，可以导出卡尔曼滤波的计算原型，包括：时间更新方程和测量更新方程。 为了便于描述，做以下说明：(1)$\hat{x}_k\in R^n$，第$k$步之前的状态已知的情况下第$k$步的先验状态估计值（$\bar{}$代表先验,$\hat{}$代表估计）；(2)$\hat{x}_k\in R^n$ ，测量变量$z_k$已知情况下第$k$步的后验状态估计值。由此定义先验估计误差和后验估计误差：</p><p> $$e_k^{-}\equiv x_k-\hat{x}_k^{-}\tag{5}$$<br> $$e_k\equiv x_k-\hat{x}_k\tag{6}\label{pos_estim_error}$$</p><p> 先验估计误差的协方差矩阵为：<br> $$P_k^{-}=E(e_k^{-}e_k^{-T})\tag{7}$$</p><p> 后验估计误差的协方差矩阵为：<br> $$P_k=E(e_ke_k^{T})\tag{8}\label{pos_estim_error_conv}$$</p><p> 先验估计$\hat{X}_k^{-}$和加权的测量变量$Z_k$及其预测$H\hat{X}_k^{-}$之差的线性组合构成了后验状态估计$\hat{X}_k$：<br> $$\hat{x}_k=\hat{x}_k^{-}+K(z_k-\hat{x}_k^{-})\tag{9}\label{pos_estim}$$</p><p> 式中测量变量及其预测值之差$(z_k-\hat{X}_k^{-})$ 反映了预测值和实际值之间的不一致程度，称为测量过程的残余。残余为零表明二者完全吻合。$n\times m$阶矩阵$K$叫做残余的增益 ，作用是使\eqref{pos_estim_error_conv}式中的后验估计误差协方差最小。 可以通过以下步骤求出 K：将\eqref{pos_estim}式代入\eqref{pos_estim_error}式代入\eqref{pos_estim_error_conv}式，将$P_k$对$K$求导，使一阶导数为零，可以求出 $K$，$K$的一种形式为：<br> $$K_k = P_k^{-}H^T(HP_k^{-}H^T+R)^{-1}\tag{10}\label{kalman_k}$$</p><p>卡尔曼滤波器用反馈控制的方法估计过程状态： 滤波器估计过程某一时刻的状态， 然后以（含噪声的） 测量变量的方式获得反馈。 因此卡尔曼滤波器可分为两个部分： 时间更新方程和测量更新方程。 时间更新方程负责及时向前推算当前状态变量和误差协方差估计的值， 以便为下一个时间状态构造先验估计。 测量更新方程负责反馈――也就是说， 它将先验估计和新的测量变量结合以构造改进的后验估计。时间更新方程也可视为预估方程， 测量更新方程可视为校正方程。 最后的估计算法成为一种具有数值解的预估－校正算法， 如下图所示。<br><img src="/2019/01/04/KalmanFilter/循环更新图.jpg" width="400" height="268" title="图1 卡尔曼滤波器循环更新图"></p><p>离散卡尔曼滤波器时间更新方程：</p><p>$$\hat{x}<em>k^{-} = A\hat{x}</em>{k-1}+Bu_{k-1}\tag{11}$$</p><p>$$P_k^{-} = AP_{k-1}A^T + Q\tag{12}$$</p><p>离散卡尔曼滤波器状态更新方程：</p><p>$$K_k = P_k^{-}H^T(HP_k^{-}H^T+R)^{-1}\tag{13}\label{kalman_gain}$$<br>$$\hat{x}_k=\hat{x}_k^{-}K_k(z_k - H\hat{x}_k^{-})\tag{14}\label{pos_estim2}$$<br>$$P_k = (I-K_kH)P_k^{-}\tag{15}\label{pos_cov}$$</p><p>测量更新方程首先做的是计算卡尔曼增益 $K_k$ 。 注意\eqref{kalman_gain}式和\eqref{kalman_k}式是相同的。 其次便测量输出以获得$z_k$， 然后按\eqref{pos_estim2}式（与\eqref{pos_estim}式相同） 产生状态的后验估计。 最后按\eqref{pos_cov}式估计状态的后验协方差。</p><p>最后，滤波器的整个操作流程如下图所示：<br><img src="/2019/01/04/KalmanFilter/卡尔曼滤波器工作原理图.jpg" width="400" height="268" title="图2 卡尔曼滤波器工作原理图"></p>]]></content>
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>视觉SLAM十四讲中的知识</title>
      <link href="/2018/12/21/SLAM%20BOOK/"/>
      <url>/2018/12/21/SLAM%20BOOK/</url>
      <content type="html"><![CDATA[<p>本文主要记录视觉SLAM十四讲中的相关知识点，此记。</p><a id="more"></a><h1 id="C-知识点"><a href="#C-知识点" class="headerlink" title="C++知识点"></a>C++知识点</h1><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>　几乎每一个有分量的程序都需要“在相同时间的多处地点处理或使用对象”的能力。为此，我们必须在程序的多个地点指向（refer to）同一对象。虽然C++语言提供引用（reference）和指针（pointer），还是不够，因为我们往往必须确保当“指向对象”的最末一个引用被删除时该对象本身也被删除，毕竟对象被删除时析构函数可以要求某些操作，例如释放内存或归还资源等等。</p><p>　　所以我们需要“当对象再也不被使用时就被清理”的语义。Class shared_ptr提供了这样的共享式拥有语义。也就是说，多个shared_ptr可以共享（或说拥有）同一对象。对象的最末一个拥有者有责任销毁对象，并清理与该对象相关的所有资源。</p><p>　　shared_ptr的目标就是，在其所指向的对象不再被使用之后（而非之前），自动释放与对象相关的资源。</p><h2 id="使用Mat-ptr模板函数"><a href="#使用Mat-ptr模板函数" class="headerlink" title="使用Mat::ptr模板函数"></a>使用Mat::ptr模板函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ushort d = depth_.ptr&lt;ushort&gt;(y)[x];</span><br><span class="line"><span class="comment">//这个还是.ptr模板函数定位像素值的方法，记住用法</span></span><br><span class="line"><span class="comment">//返回的是depth_的第y行数据的第x个的深度值</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    Mat m(400, 400, CV_8UC3, Scalar(226, 46, 166));</span><br><span class="line">    imshow(<span class="string">"Before"</span>, m);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m.rows; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (row % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// data 是 uchar* 类型的, m.ptr&lt;uchar&gt;(row) 返回第 row 行数据的首地址</span></span><br><span class="line">            <span class="comment">// 需要注意的是该行数据是按顺序存放的,也就是对于一个 3 通道的 Mat, 一个像素有</span></span><br><span class="line">            <span class="comment">// 有 3 个通道值, [B,G,R][B,G,R][B,G,R]... 所以一行长度为:</span></span><br><span class="line">            <span class="comment">// sizeof(uchar) * m.cols * m.channels() 个字节</span></span><br><span class="line">            uchar* data = m.ptr&lt;uchar&gt;(row);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; m.cols; col++)</span><br><span class="line">            &#123;</span><br><span class="line">                data[col * <span class="number">3</span>] = <span class="number">102</span>; <span class="comment">//第row行的第col个像素点的第一个通道值 Blue</span></span><br><span class="line">                data[col * <span class="number">3</span> + <span class="number">1</span>] = <span class="number">217</span>; <span class="comment">// Green</span></span><br><span class="line">                data[col * <span class="number">3</span> + <span class="number">2</span>] = <span class="number">239</span>; <span class="comment">// Red</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"After"</span>, m);     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)m.at&lt;Vec3b&gt;(<span class="number">0</span>, <span class="number">0</span>)[<span class="number">0</span>] &lt;&lt; <span class="string">','</span>; <span class="comment">//利用 Fn 1 介绍的方法输出一下像素值到控制台</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)m.at&lt;Vec3b&gt;(<span class="number">0</span>, <span class="number">0</span>)[<span class="number">1</span>] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)m.at&lt;Vec3b&gt;(<span class="number">0</span>, <span class="number">0</span>)[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    cvWaitKey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单件模式（Singleton）"><a href="#单件模式（Singleton）" class="headerlink" title="单件模式（Singleton）"></a>单件模式（Singleton）</h2><p>定义：单件模式确保一个类只有一个实例，并提供一个全局访问点。<br>把Config写成单件模式（Singleton），它只有一个全局对象，当我们设置参数文件时，创建该对象并读取参数，随后就可以在任意地方访问参数值，最后在程序结束时自动销毁。</p><h2 id="std-min-element和std-max-element"><a href="#std-min-element和std-max-element" class="headerlink" title="std::min_element和std::max_element"></a>std::min_element和std::max_element</h2><p>Returns an iterator pointing to the element with the smallest（largest） value in the range [first,last).<br>这就是书中使用了std::min_element和lambda表达式的程序，这段程序具体实现的功能是找到matches这个用来存放匹配的关键点的描述子中描述子的最小的距离，然后赋值给min_dis，matches是存放Dmatch这个描述子类的容器，所有最后会有-&gt;distance表示赋给min_dis的是距离。</p><p>返回容器或者数组中最大值和最小值。max/min_element(first,end,cmp);其中cmp为可选择参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] ( <span class="keyword">const</span> cv::DMatch&amp; m1, <span class="keyword">const</span> cv::DMatch&amp; m2 ) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> m1.distance &lt; m2.distance; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的lamda函数相当于:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> cv::DMatch&amp; m1, <span class="keyword">const</span> cv::DMatch&amp; m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m1.distance &lt; m2.distance; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际的功能就是将matches中的所有描述子进行了个排序，然后min_element取了第一个及最小的那个的distance赋给了min_dis</p><h2 id="c-11特性：auto关键字"><a href="#c-11特性：auto关键字" class="headerlink" title="c++ 11特性：auto关键字"></a>c++ 11特性：auto关键字</h2><p>auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型，类似的关键字还有decltype。举个例子：<br>用于代替冗长复杂、变量使用范围专一的变量声明。</p><p>想象一下在没有auto的时候，我们操作标准库时经常需要这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator i = vs.begin(); i != vs.end(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样看代码写代码实在烦得很。有人可能会说为何不直接使用using namespace std，这样代码可以短一点。实际上这不是该建议的方法（C++Primer对此有相关叙述）。使用auto能简化代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vs.begin(); i != vs.end(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>for循环中的i将在编译时自动推导其类型，而不用我们显式去定义那长长的一串。<br>在定义模板函数时，用于声明依赖模板参数的变量类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx,<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiply</span><span class="params">(_Tx x, _Ty y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = x*y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若不使用auto变量来声明v，那这个函数就难定义啦，不到编译的时候，谁知道x*y的真正类型是什么呢？<br>模板函数依赖于模板参数的返回值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx, <span class="keyword">typename</span> _Ty&gt;</span><br><span class="line">auto multiply(_Tx x, _Ty y)-&gt;decltype(_Tx*_Ty)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当模板函数的返回值依赖于模板的参数时，我们依旧无法在编译代码前确定模板参数的类型，故也无从知道返回值的类型，这时我们可以使用auto。格式如上所示。</p><h1 id="图像知识"><a href="#图像知识" class="headerlink" title="图像知识"></a>图像知识</h1><h2 id="OpenCV函数"><a href="#OpenCV函数" class="headerlink" title="OpenCV函数"></a>OpenCV函数</h2><p>函数cvRound，cvFloor，cvCeil 都是用一种舍入的方法将输入浮点数转换成整数：</p><p><em>cvRound:返回跟参数最接近的整数值；</em>cvFloor:返回不大于参数的最大整数值；<br>*cvCeil:返回不小于参数的最小整数值。</p><h2 id="opencv软件"><a href="#opencv软件" class="headerlink" title="opencv软件"></a>opencv软件</h2><p>opencv2和opencv3共存<br>opencv2默认安装，安装路径一般是“usr/local”，在安装opencv3时，先下载3的源码，解压后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure></p><p>更改安装目录（先在/usr/local下新建文件夹opencv3），<br><code></code> bash<br>cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local/opencv3 ..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">然后编译opencv3即可，</span><br><span class="line">``` bash</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p><p> 这样就把3安装在opencv3文件夹了(bin lib share include)</p><p> build过程中可能报错， ICV: Failed to download ICV package: ippicv_linux_20151201.tgz.<br>  Status=7;”Couldn’t connect to server”，解决方法是手动下载ippicv_linux_20151201.tgz，并替换掉opencv-3.1.0/3rdparty/ippicv/downloads/linux-*下的相应文件即可，可以直接从该地址下载：<a href="https://raw.githubusercontent.com/Itseez/opencv_3rdparty/81a676001ca8075ada498583e4166079e5744668/ippicv/ippicv_linux_20151201.tgz" target="_blank" rel="noopener">ippicv_linux_20151201.tgz</a></p><p>在使用的时候，在CMakelists.txt中，如要用3，在find_package前指明路径：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(OpenCV_DIR /usr/local/opencv3/share/OpenCV)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">3</span> REQUIRED)</span><br></pre></td></tr></table></figure></p><h2 id="ORB特征构造函数"><a href="#ORB特征构造函数" class="headerlink" title="ORB特征构造函数"></a>ORB特征构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Ptr&lt;ORB&gt; cv::ORB::create ( <span class="keyword">int</span> nfeatures = <span class="number">500</span>, </span><br><span class="line">                                <span class="keyword">float</span> scaleFactor = <span class="number">1.2f</span>,</span><br><span class="line">                                <span class="keyword">int</span> nlevels = <span class="number">8</span>,</span><br><span class="line">                                <span class="keyword">int</span> edgeThreshold = <span class="number">31</span>,</span><br><span class="line">                                <span class="keyword">int</span> firstLevel = <span class="number">0</span>,</span><br><span class="line">                                <span class="keyword">int</span> WTA_K = <span class="number">2</span>,</span><br><span class="line">                                <span class="keyword">int</span> scoreType = ORB::HARRIS_SCORE,</span><br><span class="line">                                <span class="keyword">int</span> patchSize = <span class="number">31</span>,</span><br><span class="line">                                <span class="keyword">int</span> fastThreshold = <span class="number">20</span> )</span><br><span class="line">nfeatures:需要的特征点总数；</span><br><span class="line">scaleFactor:尺度因子；</span><br><span class="line">nlevels:金字塔层数；</span><br><span class="line">edgeThreshold:边界阈值；</span><br><span class="line">firstLevel:起始层；</span><br><span class="line">WTA_K：描述子形成方法,WTA_K=<span class="number">2</span>表示，采用两两比较；</span><br><span class="line">scoreType:角点响应函数，可以选择Harris或者Fast的方法；</span><br><span class="line">patchSize:特征点邻域大小；</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++谷歌命名法</title>
      <link href="/2018/12/21/C++%E8%B0%B7%E6%AD%8C%E5%91%BD%E5%90%8D%E6%B3%95/"/>
      <url>/2018/12/21/C++%E8%B0%B7%E6%AD%8C%E5%91%BD%E5%90%8D%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本文主要记录易于理解，通用的C++命名规则，此记。</p><a id="more"></a><h2 id="一般命名规则"><a href="#一般命名规则" class="headerlink" title="一般命名规则"></a>一般命名规则</h2><p>命名需要尽量是描述性的，避免缩写（特殊情况除外，比如特别常见的缩写num）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> price_count_reader;    <span class="comment">// 没有缩写</span></span><br><span class="line"><span class="keyword">int</span> num_errors;            <span class="comment">// "num" 是常用的惯例</span></span><br><span class="line"><span class="keyword">int</span> num_dns_connections;   <span class="comment">// 大多数人都知道“DNS”代表什么</span></span><br><span class="line"><span class="keyword">int</span> lstm_size;             <span class="comment">// "LSTM" 在机器学习中是常用的缩写</span></span><br></pre></td></tr></table></figure><p>！！！！！下面是不推荐的命名方法！！！！！！！！！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;                     <span class="comment">// 毫无意义的名字.</span></span><br><span class="line"><span class="keyword">int</span> nerr;                  <span class="comment">// 模糊的缩写.</span></span><br><span class="line"><span class="keyword">int</span> n_comp_conns;          <span class="comment">// 模糊的缩写.</span></span><br><span class="line"><span class="keyword">int</span> wgc_connections;       <span class="comment">// 估计只有你们自己人知道这是代表什么.</span></span><br><span class="line"><span class="keyword">int</span> pc_reader;             <span class="comment">// 很多东西可以简写为"pc".</span></span><br><span class="line"><span class="keyword">int</span> cstmr_id;              <span class="comment">// 删除了一些中间的字母.</span></span><br><span class="line">FooBarRequestInfo fbri;    <span class="comment">// 这甚至都不是一个单词.</span></span><br></pre></td></tr></table></figure></p><p>一些众所周知，比较常用的缩写是可以的，比如i表示迭代变量，T表示模板参数。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><table><thead><tr><th>类型</th><th>命名规则</th><th>可用特殊符号</th><th>举例</th></tr></thead><tbody><tr><td>文件名</td><td>都是小写字母，可以用下划线“<em>”和破折号“-”，如果没有习惯写法，一般用下划线“</em>”</td><td>“_”和“-”</td><td>my_useful_class.cc， my_useful_class.h</td></tr><tr><td>类型名</td><td>类型名以大写字母开头，以下划线开始</td><td>无</td><td>类型名包括：classes, structs, type aliases, enums, and type template parameters ，MyExcitingClass, MyExcitingEnum.</td></tr><tr><td>变量名（一般变量名）</td><td>小写字母，单词之间加下划线</td><td>“_”</td><td>a_local_variable</td></tr><tr><td>变量名（类成员变量名）</td><td>小写字母，单词之间加下划线，词尾加下划线</td><td>“_”</td><td>a_class_data_member_</td></tr><tr><td>变量名（结构体数据成员名）</td><td>小写字母，单词之间加下划线（或单个单词）</td><td>“_”</td><td>a_struct_data_member, name,pool</td></tr><tr><td>常数命名</td><td>常数或常量表达式，需要以小写字母“k”开头，后加大写字母开头的单词，在大写字母无法区分的时候可以添加下划线</td><td>“k”,“_”</td><td>kAndroid8_0_0, kDaysInAWeek</td></tr><tr><td>函数名</td><td>常规函数名以大写字母开头，访问函数和赋值函数可以像一般变量命名规则一样</td><td>访问函数和赋值函数“_”</td><td>AddTableEntry()，访问函数和赋值函数：int count() ， void set_count(int count)</td></tr><tr><td>命名空间</td><td>都是小写字母，最上层的命名空间是基于项目名称的，需要避免和常用的命名空间产生歧义</td><td>无</td><td>websearch</td></tr><tr><td>枚举类型名</td><td>枚举类型(for both scoped and unscoped enums)参考常数或者宏定义命名规则</td><td>“_”</td><td>kEnumName 或者 ENUM_NAME</td></tr><tr><td>宏定义名</td><td>宏定义一般不要用，如果必须要用那么应该用全全大写字母，以破折号“_”间隔</td><td>“_”</td><td>MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE</td></tr></tbody></table><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><ul><li>my_useful_class.cc</li><li>my-useful-class.cc</li><li>myusefulclass.cc</li><li><p>myusefulclass_test.cc // _unittest and _regtest are deprecated.</p><h3 id="类型名"><a href="#类型名" class="headerlink" title="类型名"></a>类型名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// classes and structs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlTable</span> &#123;</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlTableTester</span> &#123;</span> ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UrlTableProperties</span> &#123;</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedefs</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, <span class="built_in">string</span>&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using aliases</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, <span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enums</span></span><br><span class="line"><span class="keyword">enum</span> UrlTableErrors &#123; ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><h4 id="一般变量名"><a href="#一般变量名" class="headerlink" title="一般变量名"></a>一般变量名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> table_name;  <span class="comment">// OK - uses underscore.</span></span><br><span class="line"><span class="built_in">string</span> tablename;   <span class="comment">// OK - all lowercase.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> tableName;   <span class="comment">// Bad - mixed case.</span></span><br></pre></td></tr></table></figure><h4 id="类成员变量名"><a href="#类成员变量名" class="headerlink" title="类成员变量名"></a>类成员变量名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableInfo</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> table_name_;  <span class="comment">// OK - underscore at end.</span></span><br><span class="line">  <span class="built_in">string</span> tablename_;   <span class="comment">// OK.</span></span><br><span class="line">  <span class="keyword">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// OK.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结构体数据成员名"><a href="#结构体数据成员名" class="headerlink" title="结构体数据成员名"></a>结构体数据成员名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UrlTableProperties</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> num_entries;</span><br><span class="line">  <span class="keyword">static</span> Pool&lt;UrlTableProperties&gt;* pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="常数命名"><a href="#常数命名" class="headerlink" title="常数命名"></a>常数命名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kAndroid8_0_0 = <span class="number">24</span>;  <span class="comment">// Android 8.0.0</span></span><br></pre></td></tr></table></figure><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AddTableEntry()</span><br><span class="line">DeleteUrl()</span><br><span class="line">OpenFileOrDie()</span><br></pre></td></tr></table></figure><p>特殊的访问函数或赋值函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_count</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br></pre></td></tr></table></figure></p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">websearch::index</span><br><span class="line">websearch::index_util</span><br><span class="line">websearch::index::frobber_internal <span class="keyword">for</span> use in frobber.h</span><br></pre></td></tr></table></figure><h3 id="枚举类型名"><a href="#枚举类型名" class="headerlink" title="枚举类型名"></a>枚举类型名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> UrlTableErrors &#123;</span><br><span class="line">  kOK = <span class="number">0</span>,</span><br><span class="line">  kErrorOutOfMemory,</span><br><span class="line">  kErrorMalformedInput,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> AlternateUrlTableErrors &#123;</span><br><span class="line">  OK = <span class="number">0</span>,</span><br><span class="line">  OUT_OF_MEMORY = <span class="number">1</span>,</span><br><span class="line">  MALFORMED_INPUT = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="宏定义名"><a href="#宏定义名" class="headerlink" title="宏定义名"></a>宏定义名</h3><p>宏定义一般不要用，如果必须要用那么应该用全大写和下划线间隔</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND(x) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI_ROUNDED 3.0</span></span><br></pre></td></tr></table></figure><h3 id="命名规则之外"><a href="#命名规则之外" class="headerlink" title="命名规则之外"></a>命名规则之外</h3><p>如果你需要对一些C++已有命名规则之外的对象命名，可以参考现有的命名规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bigopen()</span><br><span class="line">    function name, <span class="function">follows form of <span class="title">open</span><span class="params">()</span></span></span><br><span class="line"><span class="function">uint</span></span><br><span class="line"><span class="function">    <span class="keyword">typedef</span></span></span><br><span class="line"><span class="function">bigpos</span></span><br><span class="line">    struct or class, follows form of pos</span><br><span class="line">sparse_hash_map</span><br><span class="line">    STL-like entity; follows STL naming conventions</span><br><span class="line">LONGLONG_MAX</span><br><span class="line">    a constant, as in INT_MAX</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ROS下IMU数据解析并发布-JY901（MPU9250）</title>
      <link href="/2018/05/24/ROS%E4%B8%8BIMU%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E5%B8%83/"/>
      <url>/2018/05/24/ROS%E4%B8%8BIMU%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E5%B8%83/</url>
      <content type="html"><![CDATA[<p>进行ROS下机器人系统开发，需要用到IMU数据，所以需要做IMU数据解析，IMU设备是JY901（内置MPU9250）芯片，设备利用USB转TTL转换，采用了MZ-RS24T转换器，转换芯片为FT232RL，本文想要系统记录从IMU传出数据到数据转换，再到ROS下数据解析并发布IMU话题的过程及（部分）实现方法，此记。</p><a id="more"></a><h2 id="设备连接及通信接口测试"><a href="#设备连接及通信接口测试" class="headerlink" title="设备连接及通信接口测试"></a>设备连接及通信接口测试</h2><h3 id="设备连接"><a href="#设备连接" class="headerlink" title="设备连接"></a>设备连接</h3><p>设备连接就是通过MZ-RS24T六合一转换器将TTL电平转换为USB，其中需要注意的就是将发送和接收线交叉连接，如图1所示。<br><img src="/2018/05/24/ROS下IMU数据解析并发布/imu_serial_usb_ttl.jpg" width="540" height="720" title="图1 IMU、转换器接线示意图"></p><h3 id="windows下测试设备"><a href="#windows下测试设备" class="headerlink" title="windows下测试设备"></a>windows下测试设备</h3><p>刚拿到设备需要确认设备是否可用，所以考虑在windows系统下测试，设备应该附带在windows的测试软件（miniIMUV4.3.11）和串口调试软件（SSCOM32），这些可以在他们的官方论坛<a href="http://elecmaster.net/forum.php?mod=viewthread&amp;tid=813&amp;extra=page%3D1" target="_blank" rel="noopener">维特智能</a>上下载到，也可以直接到百度网盘下载，<a href="https://pan.baidu.com/s/1J_3L_gTTH_d7ouZNegNdsw" target="_blank" rel="noopener">下载链接</a>。windows下的驱动程序可以自动搜索安装就不多说了。</p><p>一些具体的测试方法在下载资料的使用说明中有具体的介绍，安装完驱动，确定能识别硬件，验证方法到我的电脑–管理–设备管理器–端口，一般显示为USB Serial Port(COM#)，然后打开miniIMUV4.3.11，可以正常显示在配置中选定的数据，说明硬件正常。<br><img src="/2018/05/24/ROS下IMU数据解析并发布/MiniIMU.jpg" width="526" height="322" title="图2 MiniIMU软件显示界面"></p><h3 id="Linux下通信测试"><a href="#Linux下通信测试" class="headerlink" title="Linux下通信测试"></a>Linux下通信测试</h3><p>插入设备后，通过查看电脑的输入端口确定usb串口号，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/tty*</span><br></pre></td></tr></table></figure></p><p>查询到串口名为”/dev/ttyUSB0”，这样说明通信接口正常识别，后边会用的到。<br>如果在后边中通信有问题可能是串口读取权限的问题，可以采用以下方式修改权限。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 666 /dev/ttyUSB0</span><br></pre></td></tr></table></figure></p><h2 id="IMU数据解析"><a href="#IMU数据解析" class="headerlink" title="IMU数据解析"></a>IMU数据解析</h2><p>JY901模块是一款高精度的姿态测量模块，能够测量被测物体的姿态角度，以欧拉角或者四元素的方式输出。</p><p>模块的数据采用16进制的方式进行传输（在使用说明书中也有说明），这种方式的优点是效率高，可以用很少的字节传输需要的数据，比如一个数据1.523，如果用16进制方式传送的话，2个字节就够了，而用ascii码的话，需要5个字节，在需要大量数据传输的时候就比较浪费有限的带宽了。而16进制数据的缺点呢，就是可读性不强，不像Ascii码那样，直接就能读出数据了。</p><p>16进制数据传输的原理是这样的，先要确定数据的表示范围，然后是每个数据可用的字节数。比如角度的数据，每个角度的数据范围是±180度，而2个字节16进制数的表示范围是-32767-32768之间，那么我们就把±180的数据映射到±32768之间。假设原理的数据是x，变换以后的数据是y，那么y=x/180*32768。2个字节能表示的最小精度是1/32768*180=0.0055°，这对于角度的精度来说也够用了。<br>下面具体讲解析的方法。<br>在windows下先通过串口调试助手SSCOM3.2看模块的原始数据，打开相应的串口，注意要选择好正确的波特率，并且将模块的显示模式勾选为HEX显示。如图3 所示。<br><img src="/2018/05/24/ROS下IMU数据解析并发布/SSCOM3.2.jpg" width="532" height="426" title="图3 串口调试软件显示界面"></p><p>这里我们以只输出四元数数据为例来说明解析方法，由于这里我设置为只输出四元数数据，所以只有55 59开头的数据，例如55 59 F6 7A 94 00 9F 00 8B 23 FF。如果能看到这种以55 51, 55 52 或者55 53一直到55 59， 55 5A开头的数据，说明串口能够正常接收到数据了。根据使用说明书中的介绍，四元数的数据形式为<br><img src="/2018/05/24/ROS下IMU数据解析并发布/四元数数据格式.jpg" width="445" height="169" title="图4 四元数输出数据格式"><br><img src="/2018/05/24/ROS下IMU数据解析并发布/数据格式说明.jpg" width="445" height="169" title="图5 输出数据格式说明"></p><p>那么上述数据中F6 7A就是Q0的数据， 94 00就是Q1的数据，9F 00就是Q2的数据，8B 23就是Q3的数据，FF就是校验和。在Q0的数据中，F6是Q0L,7A是Q0H，那么完整的16进制数据应该是7AF6，这个16进制的数据应该如何表示为十进制的Q0数据就需要我们按照图5中的方法进行解析。</p><p>以上是在window中的串口工具读取到的数据，在Linux下我们通过serial功能包读取串口数据，下载地址<a href="https://github.com/wjwwood/serial" target="_blank" rel="noopener">Github</a>。<br>我们读取到的数据一般保存在一个std::string类型的变量中，比如strRead,这里我们首先将读取到的string数据转换为十六进制的字符串，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">string_to_hex</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> lut = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line"><span class="keyword">size_t</span> len = input.length();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> output;</span><br><span class="line">output.reserve(<span class="number">2</span> * len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> c = input[i];</span><br><span class="line">output.push_back(lut[c &gt;&gt; <span class="number">4</span>]);</span><br><span class="line">output.push_back(lut[c &amp; <span class="number">15</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> read;</span><br><span class="line"><span class="built_in">string</span> strResult;</span><br><span class="line">strResult = string_to_hex(strRead);</span><br></pre></td></tr></table></figure><p>然后我们需要根据一个数据包的报头来判断数据的开始，也就是找到55所在的位置，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_package_start = strResult.find(<span class="string">"55"</span>);</span><br></pre></td></tr></table></figure></p><p>然后我们将这样一组数据读取并保存到一个vector容器中，比如oValueList中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将string类型的十六进制数据转换为int类型,然后强制转换为unsigned short类型</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">hex2int</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; hexStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *offset;</span><br><span class="line"><span class="keyword">return</span> strtol(hexStr.c_str(), &amp;offset, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type define <span class="keyword">unsigned</span> <span class="keyword">short</span> WORD;</span><br><span class="line"><span class="built_in">vector</span>&lt;WORD&gt; oValueList;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> strResultTemp;</span><br><span class="line">WORD wordValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">strResultTemp = strResult.substr(data_package_start + <span class="number">4</span> +<span class="number">2</span>*k, <span class="number">2</span>);</span><br><span class="line">wordValue = hex2int(strResultTemp);</span><br><span class="line">oValueList.push_back(wordValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用string类的函数stbstr()，提取从55 59之后（data_package_start+4）开始的2个字符，直到校验和之前。这样我们就将原来在string类型中以十六进制形式存储的两个字符（比如F6）转存为unsigned short类型（占两个字节），并且push进vector容器中（oValueList[0]）。这样就可以通过vector容器的索引号得到四元数中各个量(Q0,Q1,Q2,Q3)的高低字节（Q0L,Q0H,Q1L,Q1H……）。然后再根据图5显示的四元数的计算方法得到相应的四元数数值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Q0 = (<span class="keyword">short</span>)(((<span class="keyword">short</span>)oValueList[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>)|oValueList[<span class="number">0</span>])/<span class="number">32768.0</span>;</span><br><span class="line"><span class="keyword">double</span> Q1 = (<span class="keyword">short</span>)(((<span class="keyword">short</span>)oValueList[<span class="number">3</span>]&lt;&lt;<span class="number">8</span>)|oValueList[<span class="number">2</span>])/<span class="number">32768.0</span>;</span><br><span class="line"><span class="keyword">double</span> Q2 = (<span class="keyword">short</span>)(((<span class="keyword">short</span>)oValueList[<span class="number">5</span>]&lt;&lt;<span class="number">8</span>)|oValueList[<span class="number">4</span>])/<span class="number">32768.0</span>;</span><br><span class="line"><span class="keyword">double</span> Q3 = (<span class="keyword">short</span>)(((<span class="keyword">short</span>)oValueList[<span class="number">7</span>]&lt;&lt;<span class="number">8</span>)|oValueList[<span class="number">6</span>])/<span class="number">32768.0</span>;</span><br></pre></td></tr></table></figure></p><h2 id="发布IMU话题"><a href="#发布IMU话题" class="headerlink" title="发布IMU话题"></a>发布IMU话题</h2><p>有了四元数数据之后，就可以通过定义一个IMU数据类型，并且将四元数数据赋值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher IMU_pub = n.advertise&lt;sensor_msgs::Imu&gt;(<span class="string">"imu_data"</span>, <span class="number">20</span>);  </span><br><span class="line"></span><br><span class="line">sensor_msgs::Imu imu_data;</span><br><span class="line"></span><br><span class="line">imu_data.header.stamp = ros::Time::now();</span><br><span class="line">imu_data.header.frame_id = <span class="string">"base_link"</span>;</span><br><span class="line">imu_data.orientation.x = Q1;</span><br><span class="line">imu_data.orientation.y = Q2;</span><br><span class="line">imu_data.orientation.z = Q3;</span><br><span class="line">imu_data.orientation.w = Q0;</span><br><span class="line"></span><br><span class="line">imu_pub.publish(imu_data);</span><br></pre></td></tr></table></figure><p> 这样就成功的发布了imu话题。<br>然后利用imu_tools（<a href="https://github.com/ccny-ros-pkg/imu_tools" target="_blank" rel="noopener">下载地址</a>）中的rviz_imu_plugin方法测试imu数据。<br>测试结果如下图：</p>]]></content>
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ros </tag>
            
            <tag> imu </tag>
            
            <tag> JY901 </tag>
            
            <tag> MPU9250 </tag>
            
            <tag> 串口解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python notes</title>
      <link href="/2018/04/16/python-notes/"/>
      <url>/2018/04/16/python-notes/</url>
      <content type="html"><![CDATA[<p>记录学习Python的一些常用语法，此记。</p><a id="more"></a><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x,n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n = n <span class="number">-1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ROS nodelet 介绍</title>
      <link href="/2018/04/09/ROS-nodelet-%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/04/09/ROS-nodelet-%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>ROS的数据通信在graph结构中以topic,service和param的方式传输数据，数据交互存在一定的延时和阻塞。Nodelet 包就是为改善这一状况设计的， 使得多个算法运行在同一个进程中，并且算法间数据传输无需拷贝就可实现。 详见<a href="http://wiki.ros.org/nodelet。" target="_blank" rel="noopener">http://wiki.ros.org/nodelet。</a> 简单的讲就是可以将以前启动的多个node捆绑在一起manager，使得同一个manager里面的topic的数据传输更快，数据通讯中roscpp采用boost shared pointer方式进行publish调用，实现zero copy。Nodelet是借助pluginlib来实现插件动态加载的，文章<a href="http://www.guyuehome.com/920" target="_blank" rel="noopener">pluginlib</a>特别通俗易懂的说明了pluginlib的工作原理，在理解pluginlib的基础上看nodelet会更容易。</p><a id="more"></a><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>nodelet的工作原理类似于pluginlib，可以参考上边所说的博客中的原理图。</p><h2 id="实现一个nodelet插件类"><a href="#实现一个nodelet插件类" class="headerlink" title="实现一个nodelet插件类"></a>实现一个nodelet插件类</h2><p>nodelet的实现因为借助了pluginlib的插件动态加载，因此nodelet的实现遵循pluginlib的使用规则，主要步骤如下：</p><ol><li>创建基类，定义统一的接口。如果是基于现有的基类，则不需要这个步骤</li><li>创建nodelet插件类，继承基类，实现统一的接口</li><li>注册nodelet插件类</li><li>编译生成插件的动态链接库</li><li>将nodelet加入ROS系统</li></ol><p>接下来，我们就根据这几个步骤来实现一个简单的nodelet功能，在开始之前需要建立一个example_pkg的功能包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg example_pkg</span><br></pre></td></tr></table></figure><p>完整的功能包代码可以在<a href="">github</a>上下载。</p><h2 id="创建基类"><a href="#创建基类" class="headerlink" title="创建基类"></a>创建基类</h2><p>其中基类nodelet是现有的，所以我们不需要创建基类，只需要继承nodelet基类即可。</p><h2 id="创建nodelet插件类并注册插件类"><a href="#创建nodelet插件类并注册插件类" class="headerlink" title="创建nodelet插件类并注册插件类"></a>创建nodelet插件类并注册插件类</h2><p>接下来我们来创建MyNodeletClass类(MyNodeletClass.h)定义，放置于目录example_pkg/include/example_pkg/下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nodelet/nodelet.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> example_pkg</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyNodeletClass</span> :</span> <span class="keyword">public</span> nodelet::Nodelet</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onInit</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="comment">//要求构造函数不能带有参数，所以调用OnInit来完成需要初始化的工作</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建MyNodeletClass类实现(MyNodeletClass.cpp)，放置于目录example_pkg/src/下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this should really be in the implementation (.cpp file)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pluginlib/class_list_macros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;example_pkg/MyNodeletClass.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> example_pkg</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> MyNodeletClass::onInit()</span><br><span class="line">    &#123;</span><br><span class="line">        NODELET_DEBUG(<span class="string">"Initializing nodelet..."</span>);</span><br><span class="line">        ROS_INFO(<span class="string">"Nodelet is Ok for test!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册插件类</span></span><br><span class="line">PLUGINLIB_DECLARE_CLASS(example_pkg, MyNodeletClass, example_pkg::MyNodeletClass, nodelet::Nodelet)</span><br></pre></td></tr></table></figure><h3 id="创建插件类的描述符-nodelet-plugins-xml-，放置于目录example-pkg-plugins-下。"><a href="#创建插件类的描述符-nodelet-plugins-xml-，放置于目录example-pkg-plugins-下。" class="headerlink" title="创建插件类的描述符(nodelet_plugins.xml)，放置于目录example_pkg/plugins/下。"></a>创建插件类的描述符(nodelet_plugins.xml)，放置于目录example_pkg/plugins/下。</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">library</span> <span class="attr">path</span>=<span class="string">"lib/libexample_pkg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"example_pkg/MyNodeletClass"</span> <span class="attr">type</span>=<span class="string">"example_pkg::MyNodeletClass"</span> <span class="attr">base_class_type</span>=<span class="string">"nodelet::Nodelet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">  This is my nodelet.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">library</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这个xml文件主要描述了nodelet的动态库路径，实现类，基类，描述等信息。</p><h3 id="编译插件的动态连接库并将插件加入ROS系统"><a href="#编译插件的动态连接库并将插件加入ROS系统" class="headerlink" title="编译插件的动态连接库并将插件加入ROS系统"></a>编译插件的动态连接库并将插件加入ROS系统</h3><p>为了编译插件的功能包，需要修改CMakeLists.txt文件，修改一下内容，将插件编译为动态连接库。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(example_pkg)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Find catkin macros and libraries</span></span><br><span class="line"><span class="comment">## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)</span></span><br><span class="line"><span class="comment">## is used, also find other catkin packages</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS nodelet roscpp)</span><br><span class="line"><span class="keyword">find_package</span>(Boost REQUIRED)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">   INCLUDE_DIRS <span class="keyword">include</span></span><br><span class="line">   LIBRARIES <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">   CATKIN_DEPENDS nodelet roscpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"><span class="comment">## Build ##</span></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Specify additional locations of header files</span></span><br><span class="line"><span class="comment">## Your package locations should be listed before other locations</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">  <span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Declare a C++ library</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>  src/MyNodeletClass.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_dependencies</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> </span><br><span class="line">   <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; </span><br><span class="line">   <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">   <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对package.xml文件进行修改，添加构建和运行依赖项(nodelet和roscpp)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>nodelet<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>nodelet<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- The export tag contains other, unspecified, tags --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Other tools can request additional information be placed here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nodelet</span> <span class="attr">plugin</span>=<span class="string">"$&#123;prefix&#125;/plugins/nodelet_plugins.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们可以通过下面的命令来查看该功能包是否编译为nodelet的插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack plugins --attrib=plugin nodelet</span><br></pre></td></tr></table></figure><p>如果没有问题，会出现一系列nodelet的插件路径，其中应该有上边添加的插件的路径，我的插件路径为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">/opt/ros/kinetic/share/pcl_ros/pcl_nodelets.xml</span><br><span class="line">/home/username/catkin_turtlebot/src/example_pkg/plugins/nodelet_plugins.xml <span class="comment">#创建的插件路径</span></span><br><span class="line">/opt/ros/kinetic/share/image_publisher/nodelet_plugins.xml</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>插件的路径比较多，没有全列出来。</p><h2 id="编写启动文件-mynodelet-launch"><a href="#编写启动文件-mynodelet-launch" class="headerlink" title="编写启动文件(mynodelet.launch):"></a>编写启动文件(mynodelet.launch):</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"nodelet"</span> <span class="attr">type</span>=<span class="string">"nodelet"</span> <span class="attr">name</span>=<span class="string">"standalone_nodelet"</span>  <span class="attr">args</span>=<span class="string">"manager"</span> <span class="attr">output</span>=<span class="string">"screen"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"nodelet"</span> <span class="attr">type</span>=<span class="string">"nodelet"</span> <span class="attr">name</span>=<span class="string">"MyNodeletClass"</span> <span class="attr">args</span>=<span class="string">"load example_pkg/MyNodeletClass standalone_nodelet"</span> <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span>                 </span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编译并测试"><a href="#编译并测试" class="headerlink" title="编译并测试"></a>编译并测试</h2><p>根目录下编译后，运行launch文件，如果没有问题，可以看到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">username@username-HP-ProBook-440-G3:~/catkin_turtlebot$ roslaunch example_pkg mynodelet.launch </span><br><span class="line">... logging to /home/username/.ros/<span class="built_in">log</span>/7e42af3c-3b9c-11e8-8278-a86bad0ea915/roslaunch-username-HP-ProBook-440-G3-13823.log</span><br><span class="line">Checking <span class="built_in">log</span> directory <span class="keyword">for</span> disk usage. This may take awhile.</span><br><span class="line">Press Ctrl-C to interrupt</span><br><span class="line">Done checking <span class="built_in">log</span> file disk usage. Usage is &lt;1GB.</span><br><span class="line"></span><br><span class="line">started roslaunch server http://username-HP-ProBook-440-G3:35479/</span><br><span class="line"></span><br><span class="line">SUMMARY</span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">PARAMETERS</span><br><span class="line"> * /rosdistro: kinetic</span><br><span class="line"> * /rosversion: 1.12.13</span><br><span class="line"></span><br><span class="line">NODES</span><br><span class="line">  /</span><br><span class="line">    MyNodeletClass (nodelet/nodelet)</span><br><span class="line">    standalone_nodelet (nodelet/nodelet)</span><br><span class="line"></span><br><span class="line">ROS_MASTER_URI=http://localhost:11311</span><br><span class="line"></span><br><span class="line">process[standalone_nodelet-1]: started with pid [13840]</span><br><span class="line">process[MyNodeletClass-2]: started with pid [13841]</span><br><span class="line">[ INFO] [1523264216.026517404]: Loading nodelet /MyNodeletClass of <span class="built_in">type</span> example_pkg/MyNodeletClass to manager standalone_nodelet with the following remappings:</span><br><span class="line">[ INFO] [1523264216.027989431]: waitForService: Service [/standalone_nodelet/load_nodelet] has not been advertised, waiting...</span><br><span class="line">[ INFO] [1523264216.071444856]: Initializing nodelet with 4 worker threads.</span><br><span class="line">[ INFO] [1523264216.090658134]: waitForService: Service [/standalone_nodelet/load_nodelet] is now available.</span><br><span class="line">[ INFO] [1523264216.092255988]: Nodelet is Ok <span class="keyword">for</span> <span class="built_in">test</span>!!</span><br></pre></td></tr></table></figure><p>成功后会显示Nodelet is Ok for test!!<br>这样，我们就完成了nodelet插件的实现和调用。</p>]]></content>
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ros </tag>
            
            <tag> nodelet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正交矩阵的凯莱公式</title>
      <link href="/2018/03/30/%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E7%9A%84%E5%87%AF%E8%8E%B1%E5%85%AC%E5%BC%8F/"/>
      <url>/2018/03/30/%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5%E7%9A%84%E5%87%AF%E8%8E%B1%E5%85%AC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>本文主要说明一个线性代数的主要结论-正交矩阵的凯莱公式：<br>对于任何正交矩阵 $R$, 存在一个反对称矩阵 $S$, 满足 $R=(I_3-S)^{-1}(I_3+S)$ ，此记！<br><a id="more"></a></p><p>对于原点 $O$ 的一个旋转表示为：<br>\begin{equation}<br>P’=AP<br>\end{equation}<br>其中， $A$ 是一个正交矩阵。因为旋转后的向量长度不发生变化，所以 $({OP})^2=({OP’})^2$ ，并且<br>$$P’\cdot P’-P\cdot P=0$$<br>或者表示为：<br>\begin{equation}<br>(P’-P)\cdot (P’+P)=0<br>\end{equation}<br>其中， $P$ 是任意向量。因此可以得到 $f=P’-P$ 和 $g=P’+P$ 是正交向量。将 $f$，$g$ 和 $P$ 以列向量的形式表示，得到<br>\begin{equation}<br>f=(A-I)P, g=(A+I)P, f\cdot g=0<br>\end{equation}<br>排除 $-1$ 是矩阵 $A$ 的特征值的特例， $A+I$ 就是一个非奇异矩阵，并且<br>\begin{equation}<br>P=(A+I)^{-1}g<br>\end{equation}<br>那么，<br>$$f=(A-I)(A+I)^{-1}g.$$<br>假设<br>\begin{equation}<br>(A-I)(A+I)^{-1}=B，\star<br>\end{equation}<br>那么，<br>\begin{equation}<br>f=Bg<br>\end{equation}<br>假设 $B=[b_{ik}]$ ， $g_i$ 是向量 $g$ 的元素。那么，对于任意的向量 $g$ ， $f\cdot g=0$ 可以改写为：<br>$$\sum_{i,k}(b_{ik}+b_{ki})g_ig_k=0$$<br>那么就可以得到：对于所有的 $i,k$ ， $b_{ik}+b_{ki}=0$ 。因此矩阵$B$是反对称矩阵(skew matrix)。根据公式 $\star$ 可得：<br>$$A-I=B(A+I)$$<br>或者<br>\begin{equation}<br>(I-B)A=I+B<br>\end{equation}</p><p>我们知道，如果矩阵$B$是一个实反对称矩阵，那么 $|B|\geq 0$ 。因此， $|B+\lambda I|$ 是关于 $\lambda$ 的带非负系数的多项式，并且除了取 $\lambda=0$ 外多项式的值不为0。也就说 $|B-I|\neq 0$ 。</p><p>可以得到结论：对于任意的 $-1$ 不是它的特征值的正交矩阵，正交矩阵可以写为：<br>\begin{equation}<br>A=(I-B)^{-1}(I+B)<br>\end{equation}<br>其中， $B$ 是反对称矩阵，以上公式成为称为凯莱公式。</p><p>参考文献：</p><p>[1]Bottema O, Roth B. Theoretical Kinematics[M]. North-holland Publishing, 1979，pp: 9-10.</p>]]></content>
      
      <categories>
          
          <category> Robotics </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>等效轴角坐标系表示法</title>
      <link href="/2018/03/30/%E7%AD%89%E6%95%88%E8%BD%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
      <url>/2018/03/30/%E7%AD%89%E6%95%88%E8%BD%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本文主要讲述等效轴角坐标系表示法的导出过程，其中涉及到罗德里格斯公式（<a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula" target="_blank" rel="noopener">Rodrigues’ rotation formula</a>）的推导，此记。</p><a id="more"></a><p>首先将坐标系 $B$ 和一个已知参考坐标系 $A$ 重合。将 $B$ 绕矢量 $^A\hat{K}$ 按右手定则旋转 $\theta$ 角度。<br>等效旋转矩阵的表示形式推导：</p><p>目标：将向量 $v=(x,y,z)$ 绕一般方向（而不是主轴方向） $\hat{r}$ （假设 $\hat{r}$ 是单位向量，如果不是，先进行单位化）旋转 $\theta$ 角度，如图1所示。</p><img src="/2018/03/30/等效轴角坐标系表示法/等效轴角坐标系表示法1.jpg" width="400" height="268" title="图1 旋转立体示意图"><p>首先，将向量 $v$ 分解为两部分：平行于 $\hat{r}$ 的 $v_{||}$ 和垂直于 $\hat{r}$ 的 $v_{\bot}$，并且很容易可以得到:</p><p>$$v_{||}=(v\cdot \hat{r})\hat{r}$$</p><p>$$v=v_{||}+v_{\bot}$$</p><p>$$v_{\bot}=v-v_{||}$$</p><p>$$v_{\bot}=v-(v\cdot \hat{r})\hat{r}$$</p><p>假设，$T$ 是我们所要研究的旋转，我们需要计算 $T(v)$：</p><p>\begin{align}<br>T(v) &amp; =T(v_{||}+v_{\bot})\\<br>&amp; = T(v_{||})+T(v_{\bot})<br>\end{align}</p><p>因为 $v_{||}$ 平行于旋转轴 $hat{r}$ ，所以</p><p>$$T(v_{||})=v_{||}$$</p><p>可以得到：</p><p>$$T(v)=v_{||}+T(v_{\bot})$$</p><p>其中， $T(v_{\bot})$ 是唯一需要求解的量。所以我们建立旋转平面上的两个基向量(如下图)，把 $v_{\bot}$ 作为第一个基向量，第二个基向量用</p><p>\begin{align}<br>w &amp; =\hat{r}\times v_{\bot}\\<br> &amp; = \hat{r}\times v<br>\end{align}</p><img src="/2018/03/30/等效轴角坐标系表示法/等效轴角坐标系表示法2.jpg" width="468" height="330" title="图2 $v_{\bot}$旋转平面示意图"><p>根据图2，我们可以得到：</p><p>\begin{align}<br>T(v_{\bot}) &amp; = v_{\bot}cos\theta+ w sin\theta\\<br>&amp;= v_{\bot}cos\theta+(\hat{r}\times v)sin\theta<br>\end{align}</p><p>因此，</p><p>\begin{align}<br>T(v) &amp; =v_{||}+T(v_{\bot})\\<br>&amp;=(v\cdot \hat{r})\hat{r}+ v_{\bot}cos\theta+ (\hat{r}\times v)sin\theta\\<br>&amp;=(v\cdot \hat{r})\hat{r}+ [v-(v\cdot \hat{r})\hat{r}]cos\theta+(\hat{r}\times v)sin\theta\\<br>&amp;=(v\cdot \hat{r})\hat{r}+ vcos\theta- (v\cdot \hat{r})\hat{r}cos\theta+ (\hat{r}\times v)sin\theta\\<br>&amp;=(1-cos \theta)(v\cdot \hat{r})\hat{r}+ v cos\theta+ (\hat{r}\times v)sin\theta\end{align}</p><hr><p>得到的该式为Rodrigues公式：</p><p>$$T(v)=(1-cos \theta)(v\cdot \hat{r})\hat{r}+ v cos\theta+ (\hat{r}\times v)sin\theta$$</p><hr><p>至此，经过变换之后的向量形式已经表示出来了。可以分别通过三个基向量来求得等效旋转矩阵的一般形式：</p><p>$$p=\begin{vmatrix}1 &amp;0 &amp;0\end{vmatrix}^T $$</p><p>将向量 $p$ 绕轴 $\hat{r}=[k_x,k_y,k_z]$ 旋转(这里为了和参考书形式相同，采用 $k$ 表示)之后的形式表示为，</p><p>\begin{align}<br>p’ &amp; =(1-cos \theta)(p\cdot \hat{r})\hat{r}+ pcos\theta+(\hat{r}\times p)sin\theta\\<br>&amp;=(1-cos\theta)\left[\left(\begin{matrix}1\\0\\0\end{matrix}\right)\cdot \left(\begin{matrix}k_x\\k_y\\k_z\end{matrix}\right)\right]\left(\begin{matrix}k_x\\k_y\\k_z\end{matrix}\right)+\left(\begin{matrix}1\\0\\0\end{matrix}\right)cos\theta + \left[\left(\begin{matrix}k_x\\k_y\\k_z\end{matrix}\right)\times \left(\begin{matrix}1\\0\\0\end{matrix}\right)\right]sin\theta\\<br>&amp;=\left[\begin{matrix}k_x^2(1-cos\theta)+cos\theta\\k_xk_y(1-cos\theta)+k_zsin\theta\\k_xk_z(1-cos\theta)-k_ysin\theta\end{matrix}\right]\end{align}</p><p>类似的，可以将 $q=\begin{vmatrix}0 &amp;1 &amp;0\end{vmatrix}^T$，$r=\begin{vmatrix}0 &amp;0 &amp;1\end{vmatrix}^T$ 经过旋转之后的形式表示为：</p><p>$$q’=\left[\begin{matrix}k_xk_y(1-cos\theta)-k_z sin\theta\\k_y^2(1-cos\theta)+cos\theta\\k_yk_z(1-cos\theta)+k_xsin\theta\end{matrix}\right]$$</p><p>$$r’=\left[\begin{matrix}k_xk_z(1-cos\theta)+k_y sin\theta\\k_yk_z(1-cos\theta)-k_xsin\theta\\k_z^2(1-cos\theta)+cos\theta\end{matrix}\right]$$</p><p>最后，可以得到等效旋转阵的形式：</p><p>$$R_r(\theta)=\left[\begin{matrix}k_x^2v\theta+c\theta&amp;k_xk_yv\theta-k_zs\theta&amp;k_xk_zv\theta+k_ys\theta\\k_xk_yv\theta+k_zs\theta&amp;k_y^2v\theta+c\theta&amp;k_yk_zv\theta-k_xs\theta\\k_xk_zv\theta-k_ys\theta&amp;k_yk_zv\theta+k_xs\theta&amp;k_z^2v\theta+c\theta\end{matrix}\right]$$</p><p>其中， $c\theta=cos\theta$ , $s\theta=sin\theta$ , $v\theta=1-cos\theta$ ，$\theta$ 是由右手定则确定的，即大拇指指向 $\hat{r}$ 的正方向。</p>]]></content>
      
      <categories>
          
          <category> Robotics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rodrigues </tag>
            
            <tag> rotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/30/hello-world/"/>
      <url>/2018/03/30/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server -p 4111</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="write-the-latex-form"><a href="#write-the-latex-form" class="headerlink" title="write the latex form"></a>write the latex form</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the equation $<span class="variable">$x</span>=\sum_&#123;i=1&#125;^nx_i$$ is bla...</span><br></pre></td></tr></table></figure><p>$$\sum_{i=1}^n$$</p><h3 id="insert-figure"><a href="#insert-figure" class="headerlink" title="insert figure"></a>insert figure</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% img /等效轴角坐标系表示法/等效轴角坐标系表示法1.jpg 400 268 图1 旋转立体示意图 %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Testing </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Test</title>
      <link href="/2018/03/30/test-new-post/"/>
      <url>/2018/03/30/test-new-post/</url>
      <content type="html"><![CDATA[<p>Testing for new post</p>]]></content>
      
      <categories>
          
          <category> Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> testing </tag>
            
            <tag> another tag </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
